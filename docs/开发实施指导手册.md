# 西藏电信仓库管理系统 - 开发实施指导手册

## 文档说明

本文档以导师视角,详细讲解每个业务功能的实现原理、代码结构和关键技术点,帮助开发人员系统性地掌握项目实现。

**适用对象**: 中级Java/Vue开发者
**学习周期**: 6周
**前置知识**: Spring Boot、Vue 3、MyBatis-Plus、Element Plus基础

---

## 目录

- [阶段一: 基础框架搭建 (第1周)](#阶段一-基础框架搭建-第1周)
- [阶段二: 基础数据管理 (第2周)](#阶段二-基础数据管理-第2周)
- [阶段三: 入库与直接出库 (第3周)](#阶段三-入库与直接出库-第3周)
- [阶段四: 申请审批流程 (第4周)](#阶段四-申请审批流程-第4周)
- [阶段五: 确认领取与统计 (第5周)](#阶段五-确认领取与统计-第5周)
- [阶段六: 测试与上线 (第6周)](#阶段六-测试与上线-第6周)

---

## 阶段一: 基础框架搭建 (第1周)

### 1.1 学习目标

- 掌握Spring Boot项目结构设计
- 理解分层架构的设计原则
- 实现JWT认证授权机制
- 搭建Vue 3前端工程

### 1.2 后端框架搭建

#### 1.2.1 项目结构设计

**核心概念**: 分层架构

```
后端项目采用经典的三层架构:
- Controller层: 处理HTTP请求,参数校验,响应封装
- Service层: 业务逻辑处理,事务管理
- Mapper层: 数据访问,SQL执行

这种分层的好处:
1. 职责分离: 每层专注自己的职责
2. 易于测试: 可以单独测试每一层
3. 代码复用: Service层可被多个Controller调用
4. 易于维护: 修改数据库只需改Mapper层
```

**目录结构**:

```
backend/src/main/java/com/ct/wms/
├── WmsApplication.java              # 启动类
├── common/                          # 公共模块
│   ├── api/
│   │   ├── Result.java              # 统一响应封装
│   │   ├── PageResult.java          # 分页响应
│   │   └── ResultCode.java          # 响应码枚举
│   ├── constant/
│   │   ├── CommonConstant.java      # 通用常量
│   │   └── RedisKeyConstant.java    # Redis键常量
│   ├── exception/
│   │   ├── BusinessException.java   # 业务异常
│   │   ├── GlobalExceptionHandler.java  # 全局异常处理
│   │   └── ErrorCode.java           # 错误码枚举
│   └── annotation/
│       └── Log.java                 # 操作日志注解
├── config/                          # 配置类
│   ├── SecurityConfig.java          # Security配置
│   ├── RedisConfig.java             # Redis配置
│   ├── MybatisPlusConfig.java       # MyBatis-Plus配置
│   └── SwaggerConfig.java           # Swagger配置
├── security/                        # 认证授权
│   ├── JwtAuthenticationFilter.java # JWT过滤器
│   ├── JwtTokenProvider.java        # Token工具类
│   ├── UserDetailsServiceImpl.java  # 用户详情服务
│   └── LoginUser.java               # 登录用户信息
└── module/                          # 业务模块(后续补充)
```

#### 1.2.2 统一响应封装

**设计思想**: 所有API返回统一格式,前端统一处理

**Result.java 实现**:

```java
package com.ct.wms.common.api;

import lombok.Data;

/**
 * 统一响应封装
 *
 * 为什么要统一封装?
 * 1. 前端处理简单: 统一判断code即可
 * 2. 便于扩展: 可以统一添加字段(如timestamp)
 * 3. 规范化: 团队开发保持一致
 */
@Data
public class Result<T> {

    /**
     * 状态码
     * 200 = 成功, 400 = 参数错误, 401 = 未登录, 403 = 无权限, 500 = 服务器错误
     */
    private Integer code;

    /**
     * 提示信息: 给用户看的消息
     */
    private String message;

    /**
     * 业务数据: 泛型设计,可以返回任意类型
     */
    private T data;

    /**
     * 时间戳: 便于调试,查看请求时间
     */
    private Long timestamp;

    public Result() {
        this.timestamp = System.currentTimeMillis();
    }

    /**
     * 成功响应 - 无数据
     */
    public static <T> Result<T> success() {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("操作成功");
        return result;
    }

    /**
     * 成功响应 - 有数据
     */
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("操作成功");
        result.setData(data);
        return result;
    }

    /**
     * 成功响应 - 自定义消息
     */
    public static <T> Result<T> success(String message, T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage(message);
        result.setData(data);
        return result;
    }

    /**
     * 失败响应
     */
    public static <T> Result<T> error(Integer code, String message) {
        Result<T> result = new Result<>();
        result.setCode(code);
        result.setMessage(message);
        return result;
    }

    /**
     * 失败响应 - 业务异常
     */
    public static <T> Result<T> error(ErrorCode errorCode) {
        Result<T> result = new Result<>();
        result.setCode(errorCode.getCode());
        result.setMessage(errorCode.getMessage());
        return result;
    }
}
```

**使用示例**:

```java
// Controller中使用
@GetMapping("/{id}")
public Result<UserVO> getUser(@PathVariable Long id) {
    UserVO user = userService.getById(id);
    return Result.success(user);  // 返回成功响应
}

@PostMapping
public Result<Void> createUser(@RequestBody UserCreateDTO dto) {
    userService.create(dto);
    return Result.success("用户创建成功", null);
}

@DeleteMapping("/{id}")
public Result<Void> deleteUser(@PathVariable Long id) {
    boolean deleted = userService.deleteById(id);
    if (!deleted) {
        return Result.error(400, "用户不存在");
    }
    return Result.success();
}
```

#### 1.2.3 全局异常处理

**设计思想**: 捕获所有异常,避免堆栈信息泄露给前端

**GlobalExceptionHandler.java**:

```java
package com.ct.wms.common.exception;

import com.ct.wms.common.api.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.validation.BindException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器
 *
 * @RestControllerAdvice = @ControllerAdvice + @ResponseBody
 * 作用: 拦截所有Controller抛出的异常,统一处理
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 处理业务异常
     * 业务异常是我们主动抛出的,有明确的错误码和消息
     */
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        log.error("业务异常: code={}, message={}", e.getCode(), e.getMessage());
        return Result.error(e.getCode(), e.getMessage());
    }

    /**
     * 处理参数校验异常
     * 当@Valid校验失败时,会抛出MethodArgumentNotValidException
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<Void> handleValidException(MethodArgumentNotValidException e) {
        // 获取第一个校验失败的字段和消息
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        log.error("参数校验失败: {}", message);
        return Result.error(400, message);
    }

    /**
     * 处理未知异常
     * 所有未被捕获的异常都会走这里
     */
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常: ", e);
        // 生产环境不要暴露详细错误信息
        return Result.error(500, "系统繁忙,请稍后重试");
    }
}
```

**BusinessException.java**:

```java
package com.ct.wms.common.exception;

import lombok.Getter;

/**
 * 业务异常
 * 继承RuntimeException,可以不用在方法签名声明throws
 */
@Getter
public class BusinessException extends RuntimeException {

    private Integer code;
    private String message;

    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
        this.message = message;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
    }

    /**
     * 快速抛出异常的静态方法
     */
    public static void throwIf(boolean condition, String message) {
        if (condition) {
            throw new BusinessException(400, message);
        }
    }

    public static void throwIf(boolean condition, ErrorCode errorCode) {
        if (condition) {
            throw new BusinessException(errorCode);
        }
    }
}
```

**ErrorCode.java (错误码枚举)**:

```java
package com.ct.wms.common.exception;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * 错误码枚举
 * 统一管理业务错误码,便于维护
 */
@Getter
@AllArgsConstructor
public enum ErrorCode {

    // 通用错误码 (400-499)
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未登录或Token已过期"),
    FORBIDDEN(403, "无权限访问"),
    NOT_FOUND(404, "资源不存在"),

    // 业务错误码 (1000+)
    INVENTORY_INSUFFICIENT(1001, "库存不足"),
    APPLY_ALREADY_PROCESSED(1002, "申请已被处理"),
    APPROVAL_TIMEOUT(1003, "审批超时"),
    OUTBOUND_CANCELED(1004, "出库单已取消"),
    MATERIAL_DISABLED(1005, "物资已停用"),
    WAREHOUSE_DISABLED(1006, "仓库已禁用"),
    USERNAME_EXISTS(1007, "用户名已存在"),
    PHONE_EXISTS(1008, "手机号已注册"),
    PASSWORD_ERROR(1009, "密码错误"),
    TOKEN_EXPIRED(1010, "Token已过期");

    private final Integer code;
    private final String message;
}
```

**使用示例**:

```java
@Service
public class UserServiceImpl implements IUserService {

    @Override
    public void createUser(UserCreateDTO dto) {
        // 检查用户名是否存在
        User existUser = userMapper.selectByUsername(dto.getUsername());
        if (existUser != null) {
            // 方式1: 直接抛出异常
            throw new BusinessException(ErrorCode.USERNAME_EXISTS);
        }

        // 检查手机号是否存在
        User existPhone = userMapper.selectByPhone(dto.getPhone());
        // 方式2: 使用throwIf简化代码
        BusinessException.throwIf(existPhone != null, ErrorCode.PHONE_EXISTS);

        // 创建用户逻辑...
    }
}
```

#### 1.2.4 JWT认证授权实现

**核心概念**: JWT (JSON Web Token)

```
JWT认证流程:
1. 用户登录 → 验证用户名密码 → 生成Token → 返回给前端
2. 前端存储Token(localStorage)
3. 后续请求携带Token(请求头: Authorization: Bearer {token})
4. 后端拦截请求 → 验证Token → 解析用户信息 → 放行

JWT优势:
- 无状态: 服务器不存储Session,易于扩展
- 跨域友好: Token可跨域使用
- 性能好: 不需要查询数据库验证Session
```

**JwtTokenProvider.java (Token工具类)**:

```java
package com.ct.wms.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * JWT工具类
 * 负责Token的生成、解析、验证
 */
@Slf4j
@Component
public class JwtTokenProvider {

    /**
     * 密钥: 从配置文件读取
     * 注意: 生产环境密钥要足够复杂,至少32位
     */
    @Value("${jwt.secret}")
    private String secret;

    /**
     * Token有效期: 2小时
     */
    @Value("${jwt.expiration}")
    private Long expiration;

    /**
     * 生成密钥对象
     */
    private SecretKey getSecretKey() {
        return Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * 生成Token
     *
     * @param userId 用户ID
     * @param username 用户名
     * @return JWT Token字符串
     */
    public String generateToken(Long userId, String username) {
        // 当前时间
        Date now = new Date();
        // 过期时间 = 当前时间 + 有效期(秒)
        Date expiryDate = new Date(now.getTime() + expiration * 1000);

        // Claims: Token的负载部分,存储用户信息
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("username", username);

        // 构建JWT
        return Jwts.builder()
                .setClaims(claims)          // 设置自定义信息
                .setSubject(username)       // 设置主题(通常是用户标识)
                .setIssuedAt(now)           // 签发时间
                .setExpiration(expiryDate)  // 过期时间
                .signWith(getSecretKey())   // 签名
                .compact();                 // 生成字符串
    }

    /**
     * 从Token中解析用户ID
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = parseToken(token);
        return claims.get("userId", Long.class);
    }

    /**
     * 从Token中解析用户名
     */
    public String getUsernameFromToken(String token) {
        Claims claims = parseToken(token);
        return claims.getSubject();
    }

    /**
     * 解析Token
     */
    private Claims parseToken(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(getSecretKey())
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (ExpiredJwtException e) {
            log.error("Token已过期: {}", e.getMessage());
            throw new BusinessException(ErrorCode.TOKEN_EXPIRED);
        } catch (JwtException e) {
            log.error("Token无效: {}", e.getMessage());
            throw new BusinessException(ErrorCode.UNAUTHORIZED);
        }
    }

    /**
     * 验证Token是否有效
     */
    public boolean validateToken(String token) {
        try {
            parseToken(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

**JwtAuthenticationFilter.java (JWT过滤器)**:

```java
package com.ct.wms.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * JWT认证过滤器
 *
 * OncePerRequestFilter: 确保每个请求只执行一次
 * 执行时机: 在Spring Security过滤器链中
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final UserDetailsServiceImpl userDetailsService;

    /**
     * 过滤器核心逻辑
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                   HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        try {
            // 1. 从请求头获取Token
            String token = getTokenFromRequest(request);

            // 2. 验证Token
            if (StringUtils.hasText(token) && tokenProvider.validateToken(token)) {
                // 3. 从Token解析用户名
                String username = tokenProvider.getUsernameFromToken(token);

                // 4. 加载用户详情
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                // 5. 创建认证对象
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 6. 设置到Security上下文
                SecurityContextHolder.getContext().setAuthentication(authentication);

                log.debug("设置用户认证: username={}", username);
            }
        } catch (Exception e) {
            log.error("认证失败: {}", e.getMessage());
        }

        // 7. 继续过滤器链
        filterChain.doFilter(request, response);
    }

    /**
     * 从请求头获取Token
     * 格式: Authorization: Bearer {token}
     */
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);  // 去掉"Bearer "前缀
        }
        return null;
    }
}
```

**SecurityConfig.java (Security配置)**:

```java
package com.ct.wms.config;

import com.ct.wms.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Spring Security配置
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)  // 启用方法级权限控制
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    /**
     * 密码加密器
     * BCrypt: 单向加密,不可逆,每次加密结果不同(加盐)
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Security过滤器链配置
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // 禁用CSRF(因为使用JWT,不需要CSRF保护)
            .csrf().disable()

            // 禁用Session(JWT是无状态的)
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()

            // 配置URL访问权限
            .authorizeRequests()
                // 登录接口允许匿名访问
                .antMatchers("/api/auth/login", "/api/auth/wechat-login").permitAll()
                // Swagger文档允许访问
                .antMatchers("/doc.html", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                // 其他请求需要认证
                .anyRequest().authenticated()
            .and()

            // 添加JWT过滤器(在UsernamePasswordAuthenticationFilter之前)
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

**AuthController.java (登录控制器)**:

```java
package com.ct.wms.module.auth.controller;

import com.ct.wms.common.api.Result;
import com.ct.wms.module.auth.dto.LoginDTO;
import com.ct.wms.module.auth.vo.LoginVO;
import com.ct.wms.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;

/**
 * 认证授权控制器
 */
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider tokenProvider;

    /**
     * 用户登录
     */
    @PostMapping("/login")
    public Result<LoginVO> login(@Valid @RequestBody LoginDTO dto) {
        // 1. 根据用户名查询用户
        User user = userService.getByUsername(dto.getUsername());
        BusinessException.throwIf(user == null, "用户名或密码错误");

        // 2. 验证密码
        boolean matches = passwordEncoder.matches(dto.getPassword(), user.getPassword());
        BusinessException.throwIf(!matches, "用户名或密码错误");

        // 3. 检查用户状态
        BusinessException.throwIf(user.getStatus() == 1, "账号已被禁用");

        // 4. 生成Token
        String token = tokenProvider.generateToken(user.getId(), user.getUsername());

        // 5. 构建响应
        LoginVO vo = new LoginVO();
        vo.setToken(token);
        vo.setTokenType("Bearer");
        vo.setExpiresIn(7200);  // 2小时
        vo.setUser(userService.buildUserVO(user));

        // 6. 记录登录日志(异步)
        asyncLogService.saveLoginLog(user.getId(), dto.getLoginType(), request);

        return Result.success(vo);
    }
}
```

### 1.3 前端工程搭建

#### 1.3.1 Vite + Vue 3 项目初始化

```bash
# 创建Vue 3项目
npm create vite@latest frontend-pc -- --template vue

cd frontend-pc

# 安装依赖
npm install

# 安装Element Plus
npm install element-plus

# 安装Pinia(状态管理)
npm install pinia

# 安装Vue Router
npm install vue-router@4

# 安装Axios
npm install axios

# 安装其他工具库
npm install dayjs lodash-es @vueuse/core
```

#### 1.3.2 Axios请求封装

**request.js**:

```javascript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import { useUserStore } from '@/store/modules/user'
import router from '@/router'

/**
 * 创建Axios实例
 * 为什么要封装?
 * 1. 统一配置: baseURL、timeout等
 * 2. 统一拦截: 请求拦截添加Token,响应拦截处理错误
 * 3. 代码复用: 不用每次都写重复代码
 */
const request = axios.create({
  baseURL: import.meta.env.VITE_APP_BASE_API,  // 基础URL
  timeout: 10000  // 超时时间10秒
})

/**
 * 请求拦截器
 * 在请求发送前做什么?
 * - 添加Token到请求头
 * - 显示loading
 */
request.interceptors.request.use(
  config => {
    // 获取Token
    const userStore = useUserStore()
    const token = userStore.token

    // 如果有Token,添加到请求头
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`
    }

    return config
  },
  error => {
    console.error('请求错误:', error)
    return Promise.reject(error)
  }
)

/**
 * 响应拦截器
 * 在响应返回后做什么?
 * - 统一处理错误码
 * - Token过期处理
 * - 提示错误消息
 */
request.interceptors.response.use(
  response => {
    const res = response.data

    // 如果code不是200,认为是错误
    if (res.code !== 200) {
      // 显示错误消息
      ElMessage.error(res.message || '请求失败')

      // Token过期,跳转登录页
      if (res.code === 401 || res.code === 1010) {
        const userStore = useUserStore()
        userStore.logout()
        router.push('/login')
      }

      return Promise.reject(new Error(res.message || '请求失败'))
    }

    // 返回data部分
    return res.data
  },
  error => {
    console.error('响应错误:', error)

    // 网络错误或超时
    if (!error.response) {
      ElMessage.error('网络错误,请检查网络连接')
      return Promise.reject(error)
    }

    // HTTP错误
    const { status } = error.response
    if (status === 401) {
      ElMessage.error('登录已过期,请重新登录')
      const userStore = useUserStore()
      userStore.logout()
      router.push('/login')
    } else if (status === 403) {
      ElMessage.error('没有权限访问')
    } else if (status === 500) {
      ElMessage.error('服务器错误')
    } else {
      ElMessage.error(error.message)
    }

    return Promise.reject(error)
  }
)

export default request
```

**API模块化**:

```javascript
// src/api/auth.js
import request from './request'

/**
 * 认证相关API
 */
export const authApi = {
  /**
   * 用户登录
   * @param {Object} data - {username, password, loginType}
   * @returns {Promise}
   */
  login(data) {
    return request({
      url: '/auth/login',
      method: 'post',
      data
    })
  },

  /**
   * 获取当前用户信息
   */
  getCurrentUser() {
    return request({
      url: '/auth/current-user',
      method: 'get'
    })
  },

  /**
   * 退出登录
   */
  logout() {
    return request({
      url: '/auth/logout',
      method: 'post'
    })
  }
}
```

#### 1.3.3 Pinia状态管理

**为什么需要状态管理?**

```
某些数据需要在多个组件间共享:
- 用户信息(很多地方要显示用户名)
- Token(每个请求都要用)
- 权限信息(控制菜单显示)

如果没有状态管理:
- 组件间传递复杂(props、emit)
- 数据重复存储
- 难以维护

Pinia优势:
- Vue 3官方推荐
- TypeScript支持好
- DevTools调试方便
```

**store/modules/user.js**:

```javascript
import { defineStore } from 'pinia'
import { authApi } from '@/api/auth'

/**
 * 用户状态管理
 */
export const useUserStore = defineStore('user', {
  /**
   * state: 状态数据
   * 类似组件的data
   */
  state: () => ({
    token: localStorage.getItem('token') || '',  // 从本地存储读取
    userInfo: null,
    permissions: []
  }),

  /**
   * getters: 计算属性
   * 类似组件的computed
   */
  getters: {
    // 是否已登录
    isLoggedIn: (state) => !!state.token,

    // 用户名
    username: (state) => state.userInfo?.username || '',

    // 角色编码
    roleCode: (state) => state.userInfo?.roleCode || '',

    // 是否是管理员
    isAdmin: (state) => state.userInfo?.roleCode === 'admin'
  },

  /**
   * actions: 方法
   * 类似组件的methods
   */
  actions: {
    /**
     * 登录
     */
    async login(loginForm) {
      const data = await authApi.login(loginForm)

      // 保存Token
      this.token = data.token
      localStorage.setItem('token', data.token)

      // 保存用户信息
      this.userInfo = data.user
      this.permissions = data.user.permissions || []

      return data
    },

    /**
     * 获取用户信息
     */
    async getUserInfo() {
      const data = await authApi.getCurrentUser()
      this.userInfo = data
      this.permissions = data.permissions || []
      return data
    },

    /**
     * 退出登录
     */
    async logout() {
      await authApi.logout()

      // 清除状态
      this.token = ''
      this.userInfo = null
      this.permissions = []

      // 清除本地存储
      localStorage.removeItem('token')
    },

    /**
     * 检查权限
     * @param {string} permission - 权限标识
     */
    hasPermission(permission) {
      return this.permissions.includes(permission)
    }
  }
})
```

#### 1.3.4 路由配置

**router/index.js**:

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/store/modules/user'

/**
 * 路由配置
 */
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/login/index.vue'),
    meta: { title: '登录' }
  },
  {
    path: '/',
    component: () => import('@/layout/AppLayout.vue'),
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: { title: '工作台', requireAuth: true }
      }
    ]
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

/**
 * 路由守卫
 * 作用: 在路由跳转前做权限检查
 */
router.beforeEach((to, from, next) => {
  const userStore = useUserStore()

  // 设置页面标题
  document.title = to.meta.title || '仓库管理系统'

  // 如果是登录页,直接放行
  if (to.path === '/login') {
    // 已登录跳转到首页
    if (userStore.isLoggedIn) {
      next('/')
    } else {
      next()
    }
    return
  }

  // 需要登录的页面
  if (to.meta.requireAuth) {
    if (userStore.isLoggedIn) {
      next()
    } else {
      // 未登录跳转到登录页
      next({
        path: '/login',
        query: { redirect: to.fullPath }  // 登录后跳回原页面
      })
    }
  } else {
    next()
  }
})

export default router
```

### 1.4 本阶段关键要点总结

**后端关键点**:
1. **分层架构**: Controller → Service → Mapper,职责清晰
2. **统一响应**: Result封装,前端统一处理
3. **异常处理**: 全局异常处理器,避免堆栈泄露
4. **JWT认证**: 无状态认证,Token生成与验证

**前端关键点**:
1. **Axios封装**: 请求/响应拦截,统一处理Token和错误
2. **Pinia状态管理**: 用户信息、Token等共享数据
3. **路由守卫**: 登录检查,权限控制

**调试技巧**:
- 后端: 使用Postman测试API,查看Swagger文档
- 前端: 使用Vue DevTools查看Pinia状态
- 网络: Chrome开发者工具Network标签查看请求

**常见问题**:
1. **CORS跨域**: 开发环境用Vite代理,生产环境Nginx配置
2. **Token失效**: 检查过期时间,刷新Token机制
3. **权限问题**: 检查Security配置,@PreAuthorize注解

---

## 阶段二: 基础数据管理 (第2周)

### 2.1 学习目标

- 掌握CRUD操作的标准实现
- 理解MyBatis-Plus的使用方式
- 学会参数校验和数据转换
- 掌握分页查询的实现

### 2.2 物资管理实现

#### 2.2.1 业务逻辑分析

**物资管理核心功能**:
1. 物资列表查询(支持分页、筛选、搜索)
2. 物资详情查询(含库存信息)
3. 新增物资
4. 编辑物资
5. 删除物资(软删除,有库存不能删)

**业务规则**:
- 物资编码全局唯一
- 停用物资不能用于新的出入库
- 有库存的物资不能删除(只能停用)

#### 2.2.2 数据库实体类

**Material.java**:

```java
package com.ct.wms.module.material.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 物资实体类
 *
 * @TableName: 指定表名
 * @TableId: 主键,自增
 * @TableLogic: 逻辑删除字段
 */
@Data
@TableName("tb_material")
public class Material {

    /**
     * 主键ID
     * type = IdType.AUTO: 自增主键
     */
    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 物资名称
     */
    private String materialName;

    /**
     * 物资编码(唯一)
     */
    private String materialCode;

    /**
     * 物资类别
     */
    private String category;

    /**
     * 规格型号
     */
    private String spec;

    /**
     * 单位(条/台/米/个)
     */
    private String unit;

    /**
     * 单价
     */
    private BigDecimal price;

    /**
     * 最低库存预警阈值
     */
    private BigDecimal minStock;

    /**
     * 描述
     */
    private String description;

    /**
     * 图片URL
     */
    private String image;

    /**
     * 状态: 0启用 1停用
     */
    private Integer status;

    /**
     * 逻辑删除: 0未删除 1已删除
     * @TableLogic: MyBatis-Plus会自动处理删除和查询
     */
    @TableLogic
    private Integer isDeleted;

    /**
     * 创建人ID
     */
    private Long createBy;

    /**
     * 创建时间
     * fill = FieldFill.INSERT: 插入时自动填充
     */
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    /**
     * 更新人ID
     */
    private Long updateBy;

    /**
     * 更新时间
     * fill = FieldFill.INSERT_UPDATE: 插入和更新时自动填充
     */
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

#### 2.2.3 DTO和VO设计

**为什么要DTO和VO?**

```
DTO (Data Transfer Object): 数据传输对象
- 用于接收前端传来的数据
- 可以做参数校验(@Valid)
- 字段可以和实体类不同

VO (View Object): 视图对象
- 返回给前端的数据
- 可以组合多个表的数据
- 可以格式化数据(如时间、金额)

为什么不直接用Entity?
1. 安全: Entity包含敏感字段(如密码)
2. 解耦: DTO/VO变化不影响数据库
3. 灵活: 可以自由定义字段
```

**MaterialCreateDTO.java**:

```java
package com.ct.wms.module.material.dto;

import lombok.Data;

import javax.validation.constraints.*;
import java.math.BigDecimal;

/**
 * 创建物资DTO
 * 使用javax.validation做参数校验
 */
@Data
public class MaterialCreateDTO {

    /**
     * @NotBlank: 不能为null,且去空格后长度>0
     * message: 校验失败的提示信息
     */
    @NotBlank(message = "物资名称不能为空")
    @Size(max = 100, message = "物资名称长度不能超过100")
    private String materialName;

    @NotBlank(message = "物资编码不能为空")
    @Pattern(regexp = "^[A-Z0-9]{3,20}$", message = "物资编码格式错误,只能包含大写字母和数字,长度3-20")
    private String materialCode;

    @NotBlank(message = "物资类别不能为空")
    private String category;

    @Size(max = 100, message = "规格型号长度不能超过100")
    private String spec;

    @NotBlank(message = "单位不能为空")
    @Size(max = 20, message = "单位长度不能超过20")
    private String unit;

    /**
     * @DecimalMin: 最小值
     */
    @DecimalMin(value = "0.00", message = "单价不能为负数")
    @Digits(integer = 10, fraction = 2, message = "单价格式错误")
    private BigDecimal price;

    @NotNull(message = "最低库存不能为空")
    @DecimalMin(value = "0.00", message = "最低库存不能为负数")
    private BigDecimal minStock;

    @Size(max = 500, message = "描述长度不能超过500")
    private String description;

    private String image;
}
```

**MaterialVO.java**:

```java
package com.ct.wms.module.material.vo;

import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * 物资列表VO
 */
@Data
public class MaterialVO {

    private Long id;
    private String materialName;
    private String materialCode;
    private String category;
    private String spec;
    private String unit;
    private BigDecimal price;
    private BigDecimal minStock;
    private String description;
    private String image;
    private Integer status;
    private String statusName;  // 状态名称: "启用"/"停用"
    private LocalDateTime createTime;

    /**
     * 库存相关(从inventory表查询)
     */
    private BigDecimal totalStock;  // 总库存
    private Integer warehouseCount;  // 仓库数量
}
```

**MaterialDetailVO.java**:

```java
package com.ct.wms.module.material.vo;

import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

/**
 * 物资详情VO
 * 包含各仓库库存信息
 */
@Data
public class MaterialDetailVO {

    private Long id;
    private String materialName;
    private String materialCode;
    private String category;
    private String spec;
    private String unit;
    private BigDecimal price;
    private BigDecimal minStock;
    private String description;
    private String image;
    private Integer status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;

    /**
     * 总库存
     */
    private BigDecimal totalStock;

    /**
     * 各仓库库存明细
     */
    private List<WarehouseStockVO> warehouses;

    /**
     * 仓库库存VO
     */
    @Data
    public static class WarehouseStockVO {
        private Long warehouseId;
        private String warehouseName;
        private BigDecimal quantity;
    }
}
```

#### 2.2.4 Mapper层实现

**MaterialMapper.java**:

```java
package com.ct.wms.module.material.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.ct.wms.module.material.entity.Material;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.math.BigDecimal;

/**
 * 物资Mapper
 * 继承BaseMapper,自动拥有CRUD方法
 */
@Mapper
public interface MaterialMapper extends BaseMapper<Material> {

    /**
     * 根据编码查询物资
     * BaseMapper没有这个方法,需要自定义
     *
     * @param materialCode 物资编码
     * @return Material
     */
    Material selectByCode(@Param("materialCode") String materialCode);

    /**
     * 查询物资总库存
     * 需要关联tb_inventory表
     */
    BigDecimal selectTotalStock(@Param("materialId") Long materialId);
}
```

**MaterialMapper.xml**:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.ct.wms.module.material.mapper.MaterialMapper">

    <!-- 根据编码查询物资 -->
    <select id="selectByCode" resultType="com.ct.wms.module.material.entity.Material">
        SELECT *
        FROM tb_material
        WHERE material_code = #{materialCode}
          AND is_deleted = 0
    </select>

    <!-- 查询物资总库存 -->
    <select id="selectTotalStock" resultType="java.math.BigDecimal">
        SELECT COALESCE(SUM(quantity), 0)
        FROM tb_inventory
        WHERE material_id = #{materialId}
          AND is_deleted = 0
    </select>

</mapper>
```

#### 2.2.5 Service层实现

**IMaterialService.java (接口)**:

```java
package com.ct.wms.module.material.service;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.IService;
import com.ct.wms.module.material.dto.MaterialCreateDTO;
import com.ct.wms.module.material.dto.MaterialQueryDTO;
import com.ct.wms.module.material.dto.MaterialUpdateDTO;
import com.ct.wms.module.material.entity.Material;
import com.ct.wms.module.material.vo.MaterialDetailVO;
import com.ct.wms.module.material.vo.MaterialVO;

import java.util.List;

/**
 * 物资服务接口
 */
public interface IMaterialService extends IService<Material> {

    /**
     * 分页查询物资列表
     */
    Page<MaterialVO> pageList(MaterialQueryDTO dto);

    /**
     * 查询物资详情
     */
    MaterialDetailVO getDetail(Long id);

    /**
     * 创建物资
     */
    Long create(MaterialCreateDTO dto);

    /**
     * 更新物资
     */
    void update(Long id, MaterialUpdateDTO dto);

    /**
     * 删除物资(软删除)
     */
    void delete(Long id);

    /**
     * 获取所有物资类别
     */
    List<String> getAllCategories();
}
```

**MaterialServiceImpl.java (实现)**:

```java
package com.ct.wms.module.material.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.ct.wms.common.exception.BusinessException;
import com.ct.wms.common.exception.ErrorCode;
import com.ct.wms.module.inventory.mapper.InventoryMapper;
import com.ct.wms.module.material.dto.MaterialCreateDTO;
import com.ct.wms.module.material.dto.MaterialQueryDTO;
import com.ct.wms.module.material.dto.MaterialUpdateDTO;
import com.ct.wms.module.material.entity.Material;
import com.ct.wms.module.material.mapper.MaterialMapper;
import com.ct.wms.module.material.service.IMaterialService;
import com.ct.wms.module.material.vo.MaterialDetailVO;
import com.ct.wms.module.material.vo.MaterialVO;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 物资服务实现类
 *
 * @RequiredArgsConstructor: Lombok注解,自动生成包含final字段的构造器
 * @Transactional: 事务注解,方法出错自动回滚
 */
@Service
@RequiredArgsConstructor
public class MaterialServiceImpl extends ServiceImpl<MaterialMapper, Material>
        implements IMaterialService {

    private final MaterialMapper materialMapper;
    private final InventoryMapper inventoryMapper;

    /**
     * 分页查询物资列表
     *
     * 实现思路:
     * 1. 构建查询条件(category、status、keyword)
     * 2. 执行分页查询
     * 3. 转换Entity为VO
     * 4. 查询每个物资的总库存
     */
    @Override
    public Page<MaterialVO> pageList(MaterialQueryDTO dto) {
        // 1. 创建分页对象
        Page<Material> page = new Page<>(dto.getPageNum(), dto.getPageSize());

        // 2. 构建查询条件
        LambdaQueryWrapper<Material> wrapper = new LambdaQueryWrapper<>();

        // 类别筛选
        if (dto.getCategory() != null) {
            wrapper.eq(Material::getCategory, dto.getCategory());
        }

        // 状态筛选
        if (dto.getStatus() != null) {
            wrapper.eq(Material::getStatus, dto.getStatus());
        }

        // 关键词搜索(物资名称或编码)
        if (dto.getKeyword() != null) {
            wrapper.and(w -> w
                    .like(Material::getMaterialName, dto.getKeyword())
                    .or()
                    .like(Material::getMaterialCode, dto.getKeyword())
            );
        }

        // 按创建时间倒序
        wrapper.orderByDesc(Material::getCreateTime);

        // 3. 执行分页查询
        Page<Material> materialPage = materialMapper.selectPage(page, wrapper);

        // 4. 转换为VO
        Page<MaterialVO> voPage = new Page<>();
        BeanUtils.copyProperties(materialPage, voPage);

        List<MaterialVO> voList = materialPage.getRecords().stream().map(material -> {
            MaterialVO vo = new MaterialVO();
            BeanUtils.copyProperties(material, vo);

            // 状态名称
            vo.setStatusName(material.getStatus() == 0 ? "启用" : "停用");

            // 查询总库存
            BigDecimal totalStock = materialMapper.selectTotalStock(material.getId());
            vo.setTotalStock(totalStock);

            return vo;
        }).collect(Collectors.toList());

        voPage.setRecords(voList);
        return voPage;
    }

    /**
     * 查询物资详情
     */
    @Override
    public MaterialDetailVO getDetail(Long id) {
        // 1. 查询物资基本信息
        Material material = materialMapper.selectById(id);
        BusinessException.throwIf(material == null, ErrorCode.NOT_FOUND);

        // 2. 转换为VO
        MaterialDetailVO vo = new MaterialDetailVO();
        BeanUtils.copyProperties(material, vo);

        // 3. 查询总库存
        BigDecimal totalStock = materialMapper.selectTotalStock(id);
        vo.setTotalStock(totalStock);

        // 4. 查询各仓库库存
        List<MaterialDetailVO.WarehouseStockVO> warehouses =
                inventoryMapper.selectWarehouseStockByMaterial(id);
        vo.setWarehouses(warehouses);

        return vo;
    }

    /**
     * 创建物资
     *
     * 业务规则:
     * 1. 物资编码唯一性校验
     * 2. 默认状态为启用
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long create(MaterialCreateDTO dto) {
        // 1. 检查编码是否存在
        Material existCode = materialMapper.selectByCode(dto.getMaterialCode());
        BusinessException.throwIf(existCode != null, "物资编码已存在");

        // 2. DTO转Entity
        Material material = new Material();
        BeanUtils.copyProperties(dto, material);
        material.setStatus(0);  // 默认启用

        // 3. 保存到数据库
        materialMapper.insert(material);

        return material.getId();
    }

    /**
     * 更新物资
     *
     * 业务规则:
     * 1. 物资编码不能修改(前端不传)
     * 2. 只更新传入的字段
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void update(Long id, MaterialUpdateDTO dto) {
        // 1. 检查物资是否存在
        Material material = materialMapper.selectById(id);
        BusinessException.throwIf(material == null, ErrorCode.NOT_FOUND);

        // 2. 更新字段
        BeanUtils.copyProperties(dto, material);
        material.setId(id);

        // 3. 保存
        materialMapper.updateById(material);
    }

    /**
     * 删除物资(软删除)
     *
     * 业务规则:
     * 1. 有库存的物资不能删除
     * 2. 软删除,数据不会真正删除
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void delete(Long id) {
        // 1. 检查物资是否存在
        Material material = materialMapper.selectById(id);
        BusinessException.throwIf(material == null, ErrorCode.NOT_FOUND);

        // 2. 检查是否有库存
        BigDecimal totalStock = materialMapper.selectTotalStock(id);
        if (totalStock.compareTo(BigDecimal.ZERO) > 0) {
            throw new BusinessException(400, "该物资有库存,无法删除");
        }

        // 3. 软删除(MyBatis-Plus自动处理)
        materialMapper.deleteById(id);
    }

    /**
     * 获取所有物资类别
     */
    @Override
    public List<String> getAllCategories() {
        return materialMapper.selectList(null)
                .stream()
                .map(Material::getCategory)
                .distinct()
                .collect(Collectors.toList());
    }
}
```

#### 2.2.6 Controller层实现

**MaterialController.java**:

```java
package com.ct.wms.module.material.controller;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.ct.wms.common.api.Result;
import com.ct.wms.module.material.dto.MaterialCreateDTO;
import com.ct.wms.module.material.dto.MaterialQueryDTO;
import com.ct.wms.module.material.dto.MaterialUpdateDTO;
import com.ct.wms.module.material.service.IMaterialService;
import com.ct.wms.module.material.vo.MaterialDetailVO;
import com.ct.wms.module.material.vo.MaterialVO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import java.util.List;

/**
 * 物资管理控制器
 *
 * @Tag: Swagger文档标签
 * @Operation: Swagger文档方法描述
 * @Valid: 启用参数校验
 * @PreAuthorize: 权限控制
 */
@Tag(name = "物资管理")
@RestController
@RequestMapping("/api/materials")
@RequiredArgsConstructor
public class MaterialController {

    private final IMaterialService materialService;

    /**
     * 分页查询物资列表
     */
    @Operation(summary = "物资列表")
    @GetMapping
    public Result<Page<MaterialVO>> list(MaterialQueryDTO dto) {
        Page<MaterialVO> page = materialService.pageList(dto);
        return Result.success(page);
    }

    /**
     * 查询物资详情
     */
    @Operation(summary = "物资详情")
    @GetMapping("/{id}")
    public Result<MaterialDetailVO> getDetail(@PathVariable Long id) {
        MaterialDetailVO vo = materialService.getDetail(id);
        return Result.success(vo);
    }

    /**
     * 创建物资
     * 权限: 只有管理员和部门管理员可以创建
     */
    @Operation(summary = "创建物资")
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'DEPT_ADMIN')")
    public Result<Long> create(@Valid @RequestBody MaterialCreateDTO dto) {
        Long id = materialService.create(dto);
        return Result.success("创建成功", id);
    }

    /**
     * 更新物资
     */
    @Operation(summary = "更新物资")
    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'DEPT_ADMIN')")
    public Result<Void> update(@PathVariable Long id,
                               @Valid @RequestBody MaterialUpdateDTO dto) {
        materialService.update(id, dto);
        return Result.success("更新成功", null);
    }

    /**
     * 删除物资
     */
    @Operation(summary = "删除物资")
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'DEPT_ADMIN')")
    public Result<Void> delete(@PathVariable Long id) {
        materialService.delete(id);
        return Result.success("删除成功", null);
    }

    /**
     * 获取物资类别
     */
    @Operation(summary = "物资类别列表")
    @GetMapping("/categories")
    public Result<List<String>> getCategories() {
        List<String> categories = materialService.getAllCategories();
        return Result.success(categories);
    }
}
```

#### 2.2.7 前端实现

**API接口定义 (api/material.js)**:

```javascript
import request from './request'

/**
 * 物资管理API
 */
export const materialApi = {
  /**
   * 物资列表
   */
  getList(params) {
    return request({
      url: '/materials',
      method: 'get',
      params
    })
  },

  /**
   * 物资详情
   */
  getDetail(id) {
    return request({
      url: `/materials/${id}`,
      method: 'get'
    })
  },

  /**
   * 创建物资
   */
  create(data) {
    return request({
      url: '/materials',
      method: 'post',
      data
    })
  },

  /**
   * 更新物资
   */
  update(id, data) {
    return request({
      url: `/materials/${id}`,
      method: 'put',
      data
    })
  },

  /**
   * 删除物资
   */
  delete(id) {
    return request({
      url: `/materials/${id}`,
      method: 'delete'
    })
  },

  /**
   * 物资类别
   */
  getCategories() {
    return request({
      url: '/materials/categories',
      method: 'get'
    })
  }
}
```

**物资列表页面 (views/material/list.vue)**:

```vue
<template>
  <div class="material-list">
    <!-- 搜索栏 -->
    <el-card class="search-card">
      <el-form :model="queryForm" inline>
        <el-form-item label="物资类别">
          <el-select v-model="queryForm.category" placeholder="请选择" clearable>
            <el-option
              v-for="cat in categories"
              :key="cat"
              :label="cat"
              :value="cat"
            />
          </el-select>
        </el-form-item>

        <el-form-item label="状态">
          <el-select v-model="queryForm.status" placeholder="请选择" clearable>
            <el-option label="启用" :value="0" />
            <el-option label="停用" :value="1" />
          </el-select>
        </el-form-item>

        <el-form-item label="关键词">
          <el-input
            v-model="queryForm.keyword"
            placeholder="物资名称或编码"
            clearable
            @keyup.enter="handleSearch"
          />
        </el-form-item>

        <el-form-item>
          <el-button type="primary" @click="handleSearch">搜索</el-button>
          <el-button @click="handleReset">重置</el-button>
          <el-button
            type="success"
            @click="handleCreate"
            v-if="hasPermission('material:create')"
          >
            新增物资
          </el-button>
        </el-form-item>
      </el-form>
    </el-card>

    <!-- 表格 -->
    <el-card class="table-card">
      <el-table
        :data="tableData"
        v-loading="loading"
        border
        stripe
      >
        <el-table-column prop="materialCode" label="物资编码" width="120" />
        <el-table-column prop="materialName" label="物资名称" width="150" />
        <el-table-column prop="category" label="类别" width="100" />
        <el-table-column prop="spec" label="规格型号" />
        <el-table-column prop="unit" label="单位" width="80" />
        <el-table-column prop="price" label="单价" width="100">
          <template #default="{ row }">
            ¥{{ row.price.toFixed(2) }}
          </template>
        </el-table-column>
        <el-table-column prop="totalStock" label="总库存" width="100">
          <template #default="{ row }">
            <el-tag :type="getStockTagType(row)">
              {{ row.totalStock }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="statusName" label="状态" width="80">
          <template #default="{ row }">
            <el-tag :type="row.status === 0 ? 'success' : 'danger'">
              {{ row.statusName }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column label="操作" width="200" fixed="right">
          <template #default="{ row }">
            <el-button link type="primary" @click="handleView(row)">
              详情
            </el-button>
            <el-button
              link
              type="primary"
              @click="handleEdit(row)"
              v-if="hasPermission('material:update')"
            >
              编辑
            </el-button>
            <el-button
              link
              type="danger"
              @click="handleDelete(row)"
              v-if="hasPermission('material:delete')"
            >
              删除
            </el-button>
          </template>
        </el-table-column>
      </el-table>

      <!-- 分页 -->
      <div class="pagination">
        <el-pagination
          v-model:current-page="queryForm.pageNum"
          v-model:page-size="queryForm.pageSize"
          :total="total"
          :page-sizes="[10, 20, 50, 100]"
          layout="total, sizes, prev, pager, next, jumper"
          @current-change="fetchList"
          @size-change="fetchList"
        />
      </div>
    </el-card>

    <!-- 表单对话框 -->
    <MaterialForm
      v-model="formVisible"
      :id="editId"
      @success="handleFormSuccess"
    />
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { materialApi } from '@/api/material'
import { useUserStore } from '@/store/modules/user'
import MaterialForm from './components/MaterialForm.vue'

const userStore = useUserStore()

// 搜索表单
const queryForm = reactive({
  pageNum: 1,
  pageSize: 20,
  category: null,
  status: null,
  keyword: null
})

// 表格数据
const tableData = ref([])
const total = ref(0)
const loading = ref(false)

// 物资类别
const categories = ref([])

// 表单对话框
const formVisible = ref(false)
const editId = ref(null)

/**
 * 获取物资列表
 */
const fetchList = async () => {
  loading.value = true
  try {
    const data = await materialApi.getList(queryForm)
    tableData.value = data.records
    total.value = data.total
  } catch (error) {
    ElMessage.error('查询失败')
  } finally {
    loading.value = false
  }
}

/**
 * 获取物资类别
 */
const fetchCategories = async () => {
  try {
    categories.value = await materialApi.getCategories()
  } catch (error) {
    console.error('获取类别失败', error)
  }
}

/**
 * 搜索
 */
const handleSearch = () => {
  queryForm.pageNum = 1
  fetchList()
}

/**
 * 重置
 */
const handleReset = () => {
  Object.assign(queryForm, {
    pageNum: 1,
    pageSize: 20,
    category: null,
    status: null,
    keyword: null
  })
  fetchList()
}

/**
 * 新增
 */
const handleCreate = () => {
  editId.value = null
  formVisible.value = true
}

/**
 * 查看详情
 */
const handleView = (row) => {
  // 跳转到详情页
  router.push(`/material/detail/${row.id}`)
}

/**
 * 编辑
 */
const handleEdit = (row) => {
  editId.value = row.id
  formVisible.value = true
}

/**
 * 删除
 */
const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm(
      `确定要删除物资"${row.materialName}"吗?`,
      '删除确认',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }
    )

    await materialApi.delete(row.id)
    ElMessage.success('删除成功')
    fetchList()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error(error.message || '删除失败')
    }
  }
}

/**
 * 表单提交成功
 */
const handleFormSuccess = () => {
  formVisible.value = false
  fetchList()
}

/**
 * 库存标签类型
 */
const getStockTagType = (row) => {
  if (row.totalStock === 0) return 'danger'
  if (row.totalStock < row.minStock) return 'warning'
  return 'success'
}

/**
 * 权限检查
 */
const hasPermission = (permission) => {
  return userStore.hasPermission(permission)
}

// 页面加载
onMounted(() => {
  fetchList()
  fetchCategories()
})
</script>

<style scoped lang="scss">
.material-list {
  padding: 20px;

  .search-card {
    margin-bottom: 20px;
  }

  .pagination {
    margin-top: 20px;
    display: flex;
    justify-content: flex-end;
  }
}
</style>
```

### 2.3 本阶段关键要点

**后端技术要点**:
1. **MyBatis-Plus**: BaseMapper自带CRUD,自定义SQL写在XML
2. **Lambda查询**: 类型安全的查询条件构建
3. **软删除**: @TableLogic自动处理
4. **参数校验**: @Valid + javax.validation注解
5. **BeanUtils.copyProperties**: 快速对象拷贝

**前端技术要点**:
1. **组合式API**: setup语法糖,ref/reactive响应式
2. **Element Plus**: UI组件库,Table/Form/Pagination
3. **权限控制**: v-if + hasPermission方法
4. **分页查询**: v-model双向绑定分页参数

**常见问题**:
1. **N+1查询**: 列表查询库存时,应该批量查询而非循环单查
2. **分页失效**: 确保使用Page对象而非普通List
3. **软删除**: 自定义SQL要加is_deleted=0条件

---

## 阶段三: 入库与直接出库 (第3周)

### 3.1 学习目标

- 掌握主从表的设计和操作
- 理解事务管理的重要性
- 学会库存更新的并发控制
- 实现单据号生成规则

### 3.2 入库管理实现

#### 3.2.1 业务逻辑分析

**入库流程**:
```
仓管员创建入库单 → 填写入库信息(类型、时间、物资明细) → 提交
→ 系统生成入库单号 → 保存主表(tb_inbound) → 保存明细表(tb_inbound_detail)
→ 更新库存(tb_inventory增加) → 记录库存流水(tb_inventory_log)
```

**关键业务规则**:
1. 入库单号自动生成: RK_仓库代码_日期_流水号
2. 入库明细至少1条
3. 数量必须大于0
4. 入库后立即增加库存
5. 整个过程需要事务保证一致性

#### 3.2.2 实体类设计

**Inbound.java (入库单主表)**:

```java
@Data
@TableName("tb_inbound")
public class Inbound {

    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 入库单号(唯一)
     */
    private String inboundNo;

    /**
     * 仓库ID
     */
    private Long warehouseId;

    /**
     * 入库类型: 1采购 2退货 3调拨 4其他
     */
    private Integer inboundType;

    /**
     * 操作人ID
     */
    private Long operatorId;

    /**
     * 入库时间
     */
    private LocalDateTime inboundTime;

    /**
     * 总金额
     */
    private BigDecimal totalAmount;

    /**
     * 备注
     */
    private String remark;

    @TableLogic
    private Integer isDeleted;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

**InboundDetail.java (入库明细表)**:

```java
@Data
@TableName("tb_inbound_detail")
public class InboundDetail {

    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 入库单ID(外键)
     */
    private Long inboundId;

    /**
     * 物资ID
     */
    private Long materialId;

    /**
     * 数量
     */
    private BigDecimal quantity;

    /**
     * 单价
     */
    private BigDecimal unitPrice;

    /**
     * 金额(quantity * unitPrice)
     */
    private BigDecimal amount;

    /**
     * 备注
     */
    private String remark;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
}
```

#### 3.2.3 DTO设计

**InboundCreateDTO.java**:

```java
@Data
public class InboundCreateDTO {

    @NotNull(message = "仓库ID不能为空")
    private Long warehouseId;

    @NotNull(message = "入库类型不能为空")
    @Min(value = 1, message = "入库类型错误")
    @Max(value = 4, message = "入库类型错误")
    private Integer inboundType;

    @NotNull(message = "入库时间不能为空")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime inboundTime;

    @Size(max = 200, message = "备注长度不能超过200")
    private String remark;

    @NotEmpty(message = "入库明细不能为空")
    @Valid
    private List<InboundDetailDTO> details;

    /**
     * 入库明细DTO
     */
    @Data
    public static class InboundDetailDTO {

        @NotNull(message = "物资ID不能为空")
        private Long materialId;

        @NotNull(message = "数量不能为空")
        @DecimalMin(value = "0.01", message = "数量必须大于0")
        private BigDecimal quantity;

        @DecimalMin(value = "0.00", message = "单价不能为负数")
        private BigDecimal unitPrice;

        @Size(max = 200, message = "备注长度不能超过200")
        private String remark;
    }
}
```

#### 3.2.4 Service实现 - 核心逻辑

**InboundServiceImpl.java**:

```java
@Service
@RequiredArgsConstructor
public class InboundServiceImpl implements IInboundService {

    private final InboundMapper inboundMapper;
    private final InboundDetailMapper detailMapper;
    private final InventoryService inventoryService;
    private final MaterialMapper materialMapper;
    private final WarehouseMapper warehouseMapper;

    /**
     * 创建入库单
     *
     * 核心逻辑:
     * 1. 校验仓库和物资
     * 2. 生成入库单号
     * 3. 保存主表
     * 4. 保存明细表
     * 5. 更新库存
     *
     * @Transactional: 确保数据一致性
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long create(InboundCreateDTO dto, Long userId) {
        // 1. 校验仓库
        Warehouse warehouse = warehouseMapper.selectById(dto.getWarehouseId());
        BusinessException.throwIf(warehouse == null, "仓库不存在");
        BusinessException.throwIf(warehouse.getStatus() == 1, ErrorCode.WAREHOUSE_DISABLED);

        // 2. 校验物资
        for (InboundDetailDTO detail : dto.getDetails()) {
            Material material = materialMapper.selectById(detail.getMaterialId());
            BusinessException.throwIf(material == null, "物资不存在");
            BusinessException.throwIf(material.getStatus() == 1, ErrorCode.MATERIAL_DISABLED);
        }

        // 3. 生成入库单号
        // 格式: RK_仓库代码_20251110_0001
        String inboundNo = generateInboundNo(warehouse.getWarehouseCode());

        // 4. 计算总金额
        BigDecimal totalAmount = dto.getDetails().stream()
                .map(detail -> {
                    BigDecimal qty = detail.getQuantity();
                    BigDecimal price = detail.getUnitPrice() != null
                            ? detail.getUnitPrice()
                            : BigDecimal.ZERO;
                    return qty.multiply(price);
                })
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        // 5. 保存主表
        Inbound inbound = new Inbound();
        BeanUtils.copyProperties(dto, inbound);
        inbound.setInboundNo(inboundNo);
        inbound.setOperatorId(userId);
        inbound.setTotalAmount(totalAmount);
        inboundMapper.insert(inbound);

        // 6. 保存明细表
        for (InboundDetailDTO detailDTO : dto.getDetails()) {
            InboundDetail detail = new InboundDetail();
            detail.setInboundId(inbound.getId());
            detail.setMaterialId(detailDTO.getMaterialId());
            detail.setQuantity(detailDTO.getQuantity());
            detail.setUnitPrice(detailDTO.getUnitPrice());

            // 计算金额
            BigDecimal amount = detailDTO.getQuantity().multiply(
                    detailDTO.getUnitPrice() != null ? detailDTO.getUnitPrice() : BigDecimal.ZERO
            );
            detail.setAmount(amount);
            detail.setRemark(detailDTO.getRemark());

            detailMapper.insert(detail);

            // 7. 更新库存(关键步骤)
            inventoryService.addStock(
                    dto.getWarehouseId(),
                    detailDTO.getMaterialId(),
                    detailDTO.getQuantity(),
                    inboundNo,
                    "入库",
                    userId
            );
        }

        return inbound.getId();
    }

    /**
     * 生成入库单号
     *
     * 规则: RK_仓库代码_日期_流水号
     * 示例: RK_WL_20251110_0001
     *
     * 实现思路:
     * 1. 查询今天该仓库的最大流水号
     * 2. 流水号+1,不足4位补0
     */
    private String generateInboundNo(String warehouseCode) {
        String today = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        String prefix = "RK_" + warehouseCode + "_" + today + "_";

        // 查询今天的最大流水号
        String maxNo = inboundMapper.selectMaxInboundNoByPrefix(prefix);

        int nextSeq = 1;
        if (maxNo != null) {
            // 提取流水号部分
            String seqStr = maxNo.substring(maxNo.lastIndexOf("_") + 1);
            nextSeq = Integer.parseInt(seqStr) + 1;
        }

        // 格式化流水号(4位,不足补0)
        String seq = String.format("%04d", nextSeq);

        return prefix + seq;
    }
}
```

#### 3.2.5 库存服务 - 并发控制

**InventoryService.java**:

```java
@Service
@RequiredArgsConstructor
public class InventoryService {

    private final InventoryMapper inventoryMapper;
    private final InventoryLogMapper logMapper;

    /**
     * 增加库存
     *
     * 并发控制:
     * 使用乐观锁,避免超卖问题
     *
     * @param warehouseId 仓库ID
     * @param materialId 物资ID
     * @param quantity 数量
     * @param relatedNo 关联单号
     * @param remark 备注
     * @param operatorId 操作人ID
     */
    @Transactional(rollbackFor = Exception.class)
    public void addStock(Long warehouseId, Long materialId, BigDecimal quantity,
                        String relatedNo, String remark, Long operatorId) {
        // 1. 查询库存记录
        Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                warehouseId, materialId
        );

        BigDecimal beforeQty;

        if (inventory == null) {
            // 2. 如果没有库存记录,创建新记录
            inventory = new Inventory();
            inventory.setWarehouseId(warehouseId);
            inventory.setMaterialId(materialId);
            inventory.setQuantity(quantity);
            inventory.setLockedQuantity(BigDecimal.ZERO);
            inventoryMapper.insert(inventory);

            beforeQty = BigDecimal.ZERO;
        } else {
            // 3. 如果有库存记录,增加数量
            beforeQty = inventory.getQuantity();
            inventory.setQuantity(beforeQty.add(quantity));

            // 乐观锁更新
            int updated = inventoryMapper.updateByIdWithOptimisticLock(inventory);
            BusinessException.throwIf(updated == 0, "库存更新失败,请重试");
        }

        // 4. 记录库存流水
        InventoryLog log = new InventoryLog();
        log.setWarehouseId(warehouseId);
        log.setMaterialId(materialId);
        log.setChangeType(1);  // 1=入库
        log.setChangeQuantity(quantity);
        log.setBeforeQuantity(beforeQty);
        log.setAfterQuantity(beforeQty.add(quantity));
        log.setRelatedNo(relatedNo);
        log.setRelatedType(1);  // 1=入库单
        log.setOperatorId(operatorId);
        log.setRemark(remark);
        logMapper.insert(log);
    }

    /**
     * 减少库存
     *
     * 核心: 检查库存是否充足
     */
    @Transactional(rollbackFor = Exception.class)
    public void reduceStock(Long warehouseId, Long materialId, BigDecimal quantity,
                           String relatedNo, String remark, Long operatorId) {
        // 1. 查询库存
        Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                warehouseId, materialId
        );

        BusinessException.throwIf(inventory == null, ErrorCode.INVENTORY_INSUFFICIENT);

        // 2. 检查库存是否充足
        BigDecimal availableQty = inventory.getQuantity().subtract(inventory.getLockedQuantity());
        if (availableQty.compareTo(quantity) < 0) {
            throw new BusinessException(ErrorCode.INVENTORY_INSUFFICIENT);
        }

        // 3. 减少库存
        BigDecimal beforeQty = inventory.getQuantity();
        inventory.setQuantity(beforeQty.subtract(quantity));

        // 乐观锁更新
        int updated = inventoryMapper.updateByIdWithOptimisticLock(inventory);
        BusinessException.throwIf(updated == 0, "库存更新失败,请重试");

        // 4. 记录流水
        InventoryLog log = new InventoryLog();
        log.setWarehouseId(warehouseId);
        log.setMaterialId(materialId);
        log.setChangeType(2);  // 2=出库
        log.setChangeQuantity(quantity.negate());  // 负数
        log.setBeforeQuantity(beforeQty);
        log.setAfterQuantity(beforeQty.subtract(quantity));
        log.setRelatedNo(relatedNo);
        log.setRelatedType(2);  // 2=出库单
        log.setOperatorId(operatorId);
        log.setRemark(remark);
        logMapper.insert(log);
    }
}
```

**InventoryMapper.xml (乐观锁实现)**:

```xml
<!-- 乐观锁更新 -->
<update id="updateByIdWithOptimisticLock">
    UPDATE tb_inventory
    SET quantity = #{quantity},
        locked_quantity = #{lockedQuantity},
        update_time = NOW(),
        version = version + 1
    WHERE id = #{id}
      AND version = #{version}
      AND is_deleted = 0
</update>
```

**为什么需要乐观锁?**

```
并发场景:
1. 用户A查询库存: 100个
2. 用户B查询库存: 100个
3. 用户A出库50个,更新库存为50
4. 用户B出库60个,更新库存为40

问题: 实际出库110个,但库存只有100个!

乐观锁方案:
1. 库存表增加version字段
2. 更新时检查version是否变化
3. WHERE id = #{id} AND version = #{version}
4. 如果version变了,更新失败,提示用户重试

这样就避免了并发问题!
```

### 3.3 直接出库实现

#### 3.3.1 业务逻辑

**直接出库**: 仓管员直接创建出库单,立即扣减库存

**流程**:
```
仓管员创建出库单 → 选择领用人、物资 → 提交
→ 检查库存是否充足 → 生成出库单号 → 保存主表和明细表
→ 扣减库存 → 记录流水 → 发送通知给领用人
```

#### 3.3.2 OutboundServiceImpl核心代码

```java
@Service
@RequiredArgsConstructor
public class OutboundServiceImpl implements IOutboundService {

    /**
     * 创建出库单(直接出库)
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Long createDirect(OutboundCreateDTO dto, Long userId) {
        // 1. 校验仓库
        Warehouse warehouse = warehouseMapper.selectById(dto.getWarehouseId());
        BusinessException.throwIf(warehouse == null, "仓库不存在");

        // 2. 校验领用人
        User receiver = userMapper.selectById(dto.getReceiverId());
        BusinessException.throwIf(receiver == null, "领用人不存在");

        // 3. 检查库存是否充足(关键!)
        for (OutboundDetailDTO detail : dto.getDetails()) {
            Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                    dto.getWarehouseId(), detail.getMaterialId()
            );

            BigDecimal available = BigDecimal.ZERO;
            if (inventory != null) {
                available = inventory.getQuantity().subtract(inventory.getLockedQuantity());
            }

            if (available.compareTo(detail.getQuantity()) < 0) {
                Material material = materialMapper.selectById(detail.getMaterialId());
                throw new BusinessException(
                        ErrorCode.INVENTORY_INSUFFICIENT,
                        String.format("物资[%s]库存不足,可用库存: %s",
                                material.getMaterialName(), available)
                );
            }
        }

        // 4. 生成出库单号
        String outboundNo = generateOutboundNo(warehouse.getWarehouseCode());

        // 5. 保存主表
        Outbound outbound = new Outbound();
        BeanUtils.copyProperties(dto, outbound);
        outbound.setOutboundNo(outboundNo);
        outbound.setSource(1);  // 1=直接创建
        outbound.setOperatorId(userId);
        outbound.setOutboundTime(LocalDateTime.now());  // 立即出库
        outbound.setStatus(1);  // 1=已出库
        outboundMapper.insert(outbound);

        // 6. 保存明细表并扣减库存
        for (OutboundDetailDTO detailDTO : dto.getDetails()) {
            // 保存明细
            OutboundDetail detail = new OutboundDetail();
            detail.setOutboundId(outbound.getId());
            detail.setMaterialId(detailDTO.getMaterialId());
            detail.setQuantity(detailDTO.getQuantity());
            detail.setRemark(detailDTO.getRemark());
            detailMapper.insert(detail);

            // 扣减库存
            inventoryService.reduceStock(
                    dto.getWarehouseId(),
                    detailDTO.getMaterialId(),
                    detailDTO.getQuantity(),
                    outboundNo,
                    "直接出库",
                    userId
            );
        }

        // 7. 发送通知给领用人(异步)
        asyncMessageService.sendOutboundNotice(outbound.getId());

        return outbound.getId();
    }

    /**
     * 生成出库单号
     */
    private String generateOutboundNo(String warehouseCode) {
        // 类似入库单号生成逻辑
        // ...
    }
}
```

### 3.4 本阶段关键要点

**核心技术要点**:
1. **主从表操作**: 先保存主表获取ID,再保存明细表
2. **事务管理**: @Transactional确保数据一致性
3. **乐观锁**: 防止并发库存问题
4. **单据号生成**: 业务规则+数据库查询
5. **库存检查**: 出库前必须检查库存充足

**常见错误**:
1. **忘记事务**: 主表保存成功,明细表失败,数据不一致
2. **库存超卖**: 不检查库存或没用锁
3. **单据号重复**: 并发生成时可能重复

**优化建议**:
1. **批量操作**: 明细表批量insert提升性能
2. **异步通知**: 发送消息用MQ,不阻塞主流程
3. **缓存库存**: 高并发场景用Redis缓存库存

---

## 阶段四: 申请审批流程 (第4周)

### 4.1 学习目标

- 掌握审批流程的实现
- 理解状态机的设计思想
- 学会自动创建关联单据
- 实现消息通知机制

### 4.2 申请流程业务分析

**申请流程**:
```
员工提交申请 → 待审批
    ↓
仓管员审批
    ├→ 通过 → 自动创建出库单(待领取) → 员工到仓库领取 → 仓管员确认 → 扣减库存
    └→ 拒绝 → 结束
```

**状态流转图**:
```
申请单状态:
0(待审批) → 1(已通过) → 3(已出库)
           ↓
           2(已拒绝)
           ↓
           4(已取消)

出库单状态(申请生成的):
0(待领取) → 1(已出库)
           ↓
           2(已取消)
```

### 4.3 申请管理实现

#### 4.3.1 实体类设计

**Apply.java**:

```java
@Data
@TableName("tb_apply")
public class Apply {

    @TableId(type = IdType.AUTO)
    private Long id;

    /**
     * 申请单号
     */
    private String applyNo;

    /**
     * 申请人ID
     */
    private Long applicantId;

    /**
     * 部门ID
     */
    private Long deptId;

    /**
     * 领用用途(必填)
     */
    private String purpose;

    /**
     * 申请时间
     */
    private LocalDateTime applyTime;

    /**
     * 状态: 0待审批 1已通过 2已拒绝 3已出库 4已取消
     */
    private Integer status;

    /**
     * 审批人ID
     */
    private Long approverId;

    /**
     * 审批时间
     */
    private LocalDateTime approvalTime;

    /**
     * 审批意见
     */
    private String approvalOpinion;

    /**
     * 拒绝原因
     */
    private String rejectReason;

    /**
     * 关联的出库单ID(审批通过后自动创建)
     */
    private Long outboundId;

    @TableLogic
    private Integer isDeleted;

    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

#### 4.3.2 申请提交

**ApplyServiceImpl.create()**:

```java
/**
 * 提交申请
 *
 * 业务规则:
 * 1. 员工只能给自己所在部门申请
 * 2. 申请的物资必须在部门仓库有库存
 * 3. 用途必填
 */
@Override
@Transactional(rollbackFor = Exception.class)
public Long create(ApplyCreateDTO dto, Long userId) {
    // 1. 查询申请人信息
    User user = userMapper.selectById(userId);
    BusinessException.throwIf(user == null, "用户不存在");

    // 2. 查询部门仓库
    Warehouse warehouse = warehouseMapper.selectByDeptId(user.getDeptId());
    BusinessException.throwIf(warehouse == null, "部门仓库不存在");

    // 3. 检查物资库存
    for (ApplyDetailDTO detail : dto.getDetails()) {
        Material material = materialMapper.selectById(detail.getMaterialId());
        BusinessException.throwIf(material == null, "物资不存在");
        BusinessException.throwIf(material.getStatus() == 1, ErrorCode.MATERIAL_DISABLED);

        // 查询可用库存
        Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                warehouse.getId(), detail.getMaterialId()
        );

        BigDecimal available = BigDecimal.ZERO;
        if (inventory != null) {
            available = inventory.getQuantity().subtract(inventory.getLockedQuantity());
        }

        // 提示库存不足(但不阻止提交,由审批人决定)
        if (available.compareTo(detail.getQuantity()) < 0) {
            log.warn("申请物资库存不足: materialId={}, request={}, available={}",
                    detail.getMaterialId(), detail.getQuantity(), available);
        }
    }

    // 4. 生成申请单号
    String applyNo = generateApplyNo(user.getDeptId());

    // 5. 保存主表
    Apply apply = new Apply();
    apply.setApplyNo(applyNo);
    apply.setApplicantId(userId);
    apply.setDeptId(user.getDeptId());
    apply.setPurpose(dto.getPurpose());
    apply.setApplyTime(LocalDateTime.now());
    apply.setStatus(0);  // 待审批
    applyMapper.insert(apply);

    // 6. 保存明细表
    for (ApplyDetailDTO detailDTO : dto.getDetails()) {
        ApplyDetail detail = new ApplyDetail();
        detail.setApplyId(apply.getId());
        detail.setMaterialId(detailDTO.getMaterialId());
        detail.setQuantity(detailDTO.getQuantity());
        detail.setRemark(detailDTO.getRemark());
        detailMapper.insert(detail);
    }

    // 7. 发送通知给仓管员(待审批)
    asyncMessageService.sendApplyNotice(apply.getId());

    return apply.getId();
}
```

#### 4.3.3 审批流程 - 核心逻辑

**ApplyServiceImpl.approve()**:

```java
/**
 * 审批申请
 *
 * 核心逻辑:
 * 1. 检查申请状态
 * 2. 通过: 自动创建出库单(待领取状态)
 * 3. 拒绝: 记录拒绝原因
 * 4. 更新申请状态
 * 5. 发送通知
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void approve(Long id, ApplyApproveDTO dto, Long approverId) {
    // 1. 查询申请单
    Apply apply = applyMapper.selectById(id);
    BusinessException.throwIf(apply == null, ErrorCode.NOT_FOUND);

    // 2. 检查状态(只能审批待审批状态)
    BusinessException.throwIf(
            apply.getStatus() != 0,
            ErrorCode.APPLY_ALREADY_PROCESSED
    );

    // 3. 检查审批人权限(是否是本部门仓管员)
    User approver = userMapper.selectById(approverId);
    BusinessException.throwIf(
            !approver.getDeptId().equals(apply.getDeptId()),
            "只能审批本部门的申请"
    );
    BusinessException.throwIf(
            !approver.getRoleCode().equals("warehouse"),
            "只有仓管员可以审批"
    );

    // 4. 查询部门仓库
    Warehouse warehouse = warehouseMapper.selectByDeptId(apply.getDeptId());

    // 5. 查询申请明细
    List<ApplyDetail> details = detailMapper.selectByApplyId(id);

    if (dto.getResult() == 1) {
        // 审批通过

        // 5.1 再次检查库存(审批时库存可能已变化)
        for (ApplyDetail detail : details) {
            Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                    warehouse.getId(), detail.getMaterialId()
            );

            BigDecimal available = BigDecimal.ZERO;
            if (inventory != null) {
                available = inventory.getQuantity().subtract(inventory.getLockedQuantity());
            }

            if (available.compareTo(detail.getQuantity()) < 0) {
                Material material = materialMapper.selectById(detail.getMaterialId());
                throw new BusinessException(
                        ErrorCode.INVENTORY_INSUFFICIENT,
                        String.format("物资[%s]库存不足,无法通过", material.getMaterialName())
                );
            }
        }

        // 5.2 自动创建出库单(关键步骤!)
        Long outboundId = createOutboundFromApply(apply, details, warehouse);

        // 5.3 更新申请单
        apply.setStatus(1);  // 已通过
        apply.setApproverId(approverId);
        apply.setApprovalTime(LocalDateTime.now());
        apply.setApprovalOpinion(dto.getOpinion());
        apply.setOutboundId(outboundId);  // 关联出库单

    } else {
        // 审批拒绝

        apply.setStatus(2);  // 已拒绝
        apply.setApproverId(approverId);
        apply.setApprovalTime(LocalDateTime.now());
        apply.setApprovalOpinion(dto.getOpinion());
        apply.setRejectReason(dto.getRejectReason());
    }

    // 6. 保存
    applyMapper.updateById(apply);

    // 7. 发送通知给申请人
    asyncMessageService.sendApprovalResultNotice(apply.getId());
}

/**
 * 从申请单自动创建出库单
 *
 * 关键点:
 * 1. source=2: 标记来源是申请
 * 2. status=0: 待领取(不立即扣库存)
 * 3. applyId: 关联申请单ID
 */
private Long createOutboundFromApply(Apply apply, List<ApplyDetail> details,
                                     Warehouse warehouse) {
    // 1. 生成出库单号
    String outboundNo = outboundService.generateOutboundNo(warehouse.getWarehouseCode());

    // 2. 创建出库单主表
    Outbound outbound = new Outbound();
    outbound.setOutboundNo(outboundNo);
    outbound.setWarehouseId(warehouse.getId());
    outbound.setOutboundType(1);  // 领用出库
    outbound.setSource(2);  // 来源: 申请创建
    outbound.setApplyId(apply.getId());  // 关联申请单
    outbound.setReceiverId(apply.getApplicantId());
    outbound.setPurpose(apply.getPurpose());
    outbound.setOperatorId(apply.getApproverId());
    outbound.setOutboundTime(null);  // 实际出库时间为空
    outbound.setStatus(0);  // 待领取
    outboundMapper.insert(outbound);

    // 3. 创建明细表
    for (ApplyDetail applyDetail : details) {
        OutboundDetail outboundDetail = new OutboundDetail();
        outboundDetail.setOutboundId(outbound.getId());
        outboundDetail.setMaterialId(applyDetail.getMaterialId());
        outboundDetail.setQuantity(applyDetail.getQuantity());
        outboundDetail.setRemark(applyDetail.getRemark());
        outboundDetailMapper.insert(outboundDetail);
    }

    return outbound.getId();
}
```

### 4.4 确认领取流程

**OutboundServiceImpl.confirm()**:

```java
/**
 * 确认出库(员工领取物资)
 *
 * 业务流程:
 * 1. 员工到仓库领取物资
 * 2. 仓管员扫码或查询出库单
 * 3. 确认出库,此时才扣减库存
 *
 * 为什么审批时不扣库存?
 * - 员工可能不来领取
 * - 可能超过7天自动取消
 * - 实际领取时库存可能不足
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void confirm(Long id, OutboundConfirmDTO dto, Long operatorId) {
    // 1. 查询出库单
    Outbound outbound = outboundMapper.selectById(id);
    BusinessException.throwIf(outbound == null, ErrorCode.NOT_FOUND);

    // 2. 检查状态(只能确认待领取状态)
    BusinessException.throwIf(
            outbound.getStatus() != 0,
            "出库单状态错误,无法确认"
    );

    // 3. 查询明细
    List<OutboundDetail> details = detailMapper.selectByOutboundId(id);

    // 4. 检查库存并扣减(关键步骤!)
    for (OutboundDetail detail : details) {
        // 再次检查库存(可能已被其他出库单占用)
        Inventory inventory = inventoryMapper.selectByWarehouseAndMaterial(
                outbound.getWarehouseId(), detail.getMaterialId()
        );

        BigDecimal available = BigDecimal.ZERO;
        if (inventory != null) {
            available = inventory.getQuantity().subtract(inventory.getLockedQuantity());
        }

        if (available.compareTo(detail.getQuantity()) < 0) {
            Material material = materialMapper.selectById(detail.getMaterialId());
            throw new BusinessException(
                    ErrorCode.INVENTORY_INSUFFICIENT,
                    String.format("物资[%s]库存不足,无法出库", material.getMaterialName())
            );
        }

        // 扣减库存
        inventoryService.reduceStock(
                outbound.getWarehouseId(),
                detail.getMaterialId(),
                detail.getQuantity(),
                outbound.getOutboundNo(),
                "确认领取",
                operatorId
        );
    }

    // 5. 更新出库单状态
    outbound.setStatus(1);  // 已出库
    outbound.setOutboundTime(LocalDateTime.now());  // 实际出库时间
    outbound.setRemark(dto.getRemark());
    outboundMapper.updateById(outbound);

    // 6. 如果是申请创建的,更新申请单状态
    if (outbound.getApplyId() != null) {
        Apply apply = applyMapper.selectById(outbound.getApplyId());
        apply.setStatus(3);  // 已出库
        applyMapper.updateById(apply);
    }

    // 7. 发送通知
    asyncMessageService.sendOutboundConfirmNotice(id);
}
```

### 4.5 超时自动取消

**定时任务实现**:

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OutboundTimeoutTask {

    private final OutboundMapper outboundMapper;
    private final ApplyMapper applyMapper;

    /**
     * 每天凌晨3点执行
     * 自动取消超过7天未领取的出库单
     */
    @Scheduled(cron = "0 0 3 * * ?")
    public void cancelTimeoutOutbound() {
        log.info("开始执行超时出库单取消任务");

        // 1. 查询超时的出库单
        // 条件: status=0(待领取) AND create_time < 当前时间-7天
        LocalDateTime deadline = LocalDateTime.now().minusDays(7);
        List<Outbound> timeoutList = outboundMapper.selectTimeoutOutbound(deadline);

        log.info("发现超时出库单: {} 条", timeoutList.size());

        // 2. 逐个取消
        for (Outbound outbound : timeoutList) {
            try {
                // 更新出库单状态
                outbound.setStatus(2);  // 已取消
                outbound.setRemark("超过7天未领取,系统自动取消");
                outboundMapper.updateById(outbound);

                // 如果是申请创建的,更新申请单状态
                if (outbound.getApplyId() != null) {
                    Apply apply = applyMapper.selectById(outbound.getApplyId());
                    apply.setStatus(4);  // 已取消
                    applyMapper.updateById(apply);
                }

                // 发送通知
                // asyncMessageService.sendTimeoutCancelNotice(outbound.getId());

                log.info("出库单已取消: outboundNo={}", outbound.getOutboundNo());
            } catch (Exception e) {
                log.error("取消出库单失败: outboundNo={}, error={}",
                        outbound.getOutboundNo(), e.getMessage());
            }
        }

        log.info("超时出库单取消任务完成");
    }
}
```

### 4.6 消息通知实现

**异步消息服务**:

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class AsyncMessageService {

    private final MessageMapper messageMapper;
    private final RabbitTemplate rabbitTemplate;

    /**
     * 发送申请提交通知(给仓管员)
     */
    @Async
    public void sendApplyNotice(Long applyId) {
        try {
            Apply apply = applyMapper.selectById(applyId);
            User applicant = userMapper.selectById(apply.getApplicantId());

            // 1. 查询部门仓管员
            List<User> warehouses = userMapper.selectWarehouseByDeptId(apply.getDeptId());

            // 2. 给每个仓管员发消息
            for (User warehouse : warehouses) {
                Message message = new Message();
                message.setUserId(warehouse.getId());
                message.setTitle("新的申请待审批");
                message.setContent(String.format(
                        "%s 提交了物资申请,申请单号: %s,请及时处理",
                        applicant.getRealName(), apply.getApplyNo()
                ));
                message.setType(2);  // 申请通知
                message.setRelatedId(applyId);
                message.setRelatedType(1);  // 申请单
                message.setIsRead(0);
                messageMapper.insert(message);
            }

            // 3. 发送微信模板消息(通过RabbitMQ)
            rabbitTemplate.convertAndSend(
                    "wechat.template.exchange",
                    "apply.created",
                    new WechatTemplateMessage(applyId, "apply_created")
            );

        } catch (Exception e) {
            log.error("发送申请通知失败: applyId={}", applyId, e);
        }
    }

    /**
     * 发送审批结果通知(给申请人)
     */
    @Async
    public void sendApprovalResultNotice(Long applyId) {
        // 类似实现...
    }
}
```

### 4.7 本阶段关键要点

**核心业务逻辑**:
1. **状态流转**: 申请单和出库单的状态要严格控制
2. **自动创建**: 审批通过自动创建出库单,需在同一事务
3. **延迟扣库存**: 审批时不扣,确认领取时才扣
4. **超时处理**: 定时任务自动取消超时单据
5. **消息通知**: 异步发送,不阻塞主流程

**状态机设计**:
```java
// 申请单状态枚举
@Getter
@AllArgsConstructor
public enum ApplyStatus {
    PENDING(0, "待审批"),
    APPROVED(1, "已通过"),
    REJECTED(2, "已拒绝"),
    COMPLETED(3, "已出库"),
    CANCELED(4, "已取消");

    private final Integer code;
    private final String name;

    /**
     * 检查状态流转是否合法
     */
    public boolean canTransitTo(ApplyStatus target) {
        // 待审批 → 已通过/已拒绝/已取消
        if (this == PENDING) {
            return target == APPROVED || target == REJECTED || target == CANCELED;
        }
        // 已通过 → 已出库/已取消
        if (this == APPROVED) {
            return target == COMPLETED || target == CANCELED;
        }
        // 其他状态不能流转
        return false;
    }
}
```

**事务边界设计**:
```
审批操作的事务范围:
1. 检查申请状态 ✓
2. 检查审批人权限 ✓
3. 检查库存 ✓
4. 创建出库单(主表+明细表) ✓
5. 更新申请单状态 ✓
6. 发送消息通知 ✗ (异步,不在事务内)

为什么消息通知要异步?
- 消息发送可能失败,不应该回滚业务
- 消息发送较慢,不应该阻塞用户
- 即使消息失败,业务数据也要保存
```

---

## 阶段五: 统计报表与小程序 (第5周)

### 5.1 统计报表实现

#### 5.1.1 出入库统计

**业务需求**: 按日期统计出入库数量和金额,生成图表

**SQL实现 (MyBatis)**:

```xml
<!-- 出入库统计 -->
<select id="selectInoutboundStats" resultType="com.ct.wms.module.stats.vo.InoutboundStatsVO">
    SELECT
        DATE(create_time) as date,
        COUNT(CASE WHEN inbound_type IS NOT NULL THEN 1 END) as inboundCount,
        COUNT(CASE WHEN outbound_type IS NOT NULL THEN 1 END) as outboundCount,
        COALESCE(SUM(CASE WHEN inbound_type IS NOT NULL THEN total_amount END), 0) as inboundAmount,
        0 as outboundAmount  -- 出库单没有金额字段
    FROM (
        SELECT create_time, inbound_type, total_amount, NULL as outbound_type
        FROM tb_inbound
        WHERE is_deleted = 0
          AND warehouse_id = #{warehouseId}
          AND create_time BETWEEN #{startDate} AND #{endDate}
        UNION ALL
        SELECT create_time, NULL as inbound_type, NULL as total_amount, outbound_type
        FROM tb_outbound
        WHERE is_deleted = 0
          AND warehouse_id = #{warehouseId}
          AND create_time BETWEEN #{startDate} AND #{endDate}
    ) t
    GROUP BY DATE(create_time)
    ORDER BY date
</select>
```

**Service实现**:

```java
@Override
public InoutboundStatsDTO getInoutboundStats(StatsQueryDTO dto) {
    // 1. 查询统计数据
    List<InoutboundStatsVO> chartData = statsMapper.selectInoutboundStats(
            dto.getStartDate(),
            dto.getEndDate(),
            dto.getWarehouseId()
    );

    // 2. 计算汇总数据
    InoutboundStatsDTO result = new InoutboundStatsDTO();
    result.setChartData(chartData);

    int totalInbound = chartData.stream()
            .mapToInt(InoutboundStatsVO::getInboundCount)
            .sum();
    int totalOutbound = chartData.stream()
            .mapToInt(InoutboundStatsVO::getOutboundCount)
            .sum();

    BigDecimal totalInboundAmount = chartData.stream()
            .map(InoutboundStatsVO::getInboundAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);

    // 3. 计算平均值
    long days = ChronoUnit.DAYS.between(dto.getStartDate(), dto.getEndDate()) + 1;

    InoutboundStatsSummaryVO summary = new InoutboundStatsSummaryVO();
    summary.setTotalInboundCount(totalInbound);
    summary.setTotalOutboundCount(totalOutbound);
    summary.setTotalInboundAmount(totalInboundAmount);
    summary.setAvgInboundPerDay(BigDecimal.valueOf(totalInbound).divide(
            BigDecimal.valueOf(days), 2, RoundingMode.HALF_UP));
    summary.setAvgOutboundPerDay(BigDecimal.valueOf(totalOutbound).divide(
            BigDecimal.valueOf(days), 2, RoundingMode.HALF_UP));

    result.setSummary(summary);
    return result;
}
```

**前端图表实现 (ECharts)**:

```vue
<template>
  <div class="stats-chart">
    <el-card>
      <template #header>
        <div class="card-header">
          <span>出入库统计</span>
          <el-date-picker
            v-model="dateRange"
            type="daterange"
            range-separator="-"
            start-placeholder="开始日期"
            end-placeholder="结束日期"
            @change="fetchData"
          />
        </div>
      </template>

      <!-- 图表容器 -->
      <div ref="chartRef" style="width: 100%; height: 400px;"></div>

      <!-- 汇总数据 -->
      <el-row :gutter="20" class="summary">
        <el-col :span="6">
          <el-statistic title="入库总次数" :value="summary.totalInboundCount" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="出库总次数" :value="summary.totalOutboundCount" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="入库总金额" :value="summary.totalInboundAmount" prefix="¥" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="日均入库" :value="summary.avgInboundPerDay" suffix="次" />
        </el-col>
      </el-row>
    </el-card>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'
import * as echarts from 'echarts'
import { statsApi } from '@/api/stats'

const chartRef = ref(null)
let chartInstance = null

const dateRange = ref([
  new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
  new Date()
])

const chartData = ref([])
const summary = ref({
  totalInboundCount: 0,
  totalOutboundCount: 0,
  totalInboundAmount: 0,
  avgInboundPerDay: 0
})

/**
 * 初始化图表
 */
const initChart = () => {
  chartInstance = echarts.init(chartRef.value)

  const option = {
    title: {
      text: '出入库趋势'
    },
    tooltip: {
      trigger: 'axis'
    },
    legend: {
      data: ['入库', '出库']
    },
    xAxis: {
      type: 'category',
      data: chartData.value.map(item => item.date)
    },
    yAxis: {
      type: 'value',
      name: '次数'
    },
    series: [
      {
        name: '入库',
        type: 'line',
        data: chartData.value.map(item => item.inboundCount),
        smooth: true,
        itemStyle: { color: '#67C23A' }
      },
      {
        name: '出库',
        type: 'line',
        data: chartData.value.map(item => item.outboundCount),
        smooth: true,
        itemStyle: { color: '#E6A23C' }
      }
    ]
  }

  chartInstance.setOption(option)
}

/**
 * 获取数据
 */
const fetchData = async () => {
  try {
    const [startDate, endDate] = dateRange.value
    const data = await statsApi.getInoutboundStats({
      startDate: formatDate(startDate),
      endDate: formatDate(endDate)
    })

    chartData.value = data.chartData
    summary.value = data.summary

    // 更新图表
    if (chartInstance) {
      updateChart()
    }
  } catch (error) {
    console.error('获取统计数据失败', error)
  }
}

/**
 * 更新图表
 */
const updateChart = () => {
  chartInstance.setOption({
    xAxis: {
      data: chartData.value.map(item => item.date)
    },
    series: [
      {
        data: chartData.value.map(item => item.inboundCount)
      },
      {
        data: chartData.value.map(item => item.outboundCount)
      }
    ]
  })
}

const formatDate = (date) => {
  return date.toISOString().split('T')[0]
}

onMounted(() => {
  fetchData()
  initChart()

  // 响应式调整图表大小
  window.addEventListener('resize', () => {
    chartInstance?.resize()
  })
})

// 监听日期变化
watch(dateRange, () => {
  fetchData()
})
</script>
```

### 5.2 小程序实现

#### 5.2.1 uni-app项目结构

```
frontend-mobile/
├── pages/
│   ├── warehouse/          # 仓管员页面
│   │   ├── home/           # 首页
│   │   ├── approval/       # 审批列表
│   │   └── quick-outbound/ # 快速出库
│   └── employee/           # 员工页面
│       ├── home/           # 首页
│       └── apply/          # 申请管理
├── components/
│   ├── MaterialCard/       # 物资卡片
│   └── ApplyCard/          # 申请卡片
├── utils/
│   └── request.js          # 请求封装
└── pages.json              # 页面配置
```

#### 5.2.2 仓管员首页

**pages/warehouse/home/home.vue**:

```vue
<template>
  <view class="warehouse-home">
    <!-- 统计卡片 -->
    <view class="stats-cards">
      <view class="stat-card" @tap="navTo('/pages/warehouse/approval/list')">
        <view class="stat-value">{{ todayStats.pendingApproval }}</view>
        <view class="stat-label">待审批</view>
      </view>
      <view class="stat-card" @tap="navTo('/pages/warehouse/outbound/list')">
        <view class="stat-value">{{ todayStats.pendingPickup }}</view>
        <view class="stat-label">待领取</view>
      </view>
      <view class="stat-card">
        <view class="stat-value">{{ todayStats.inboundCount }}</view>
        <view class="stat-label">今日入库</view>
      </view>
      <view class="stat-card">
        <view class="stat-value">{{ todayStats.outboundCount }}</view>
        <view class="stat-label">今日出库</view>
      </view>
    </view>

    <!-- 快捷操作 -->
    <view class="quick-actions">
      <view class="action-title">快捷操作</view>
      <view class="action-grid">
        <view class="action-item" @tap="quickInbound">
          <view class="action-icon">
            <u-icon name="arrow-down-circle" size="40" color="#67C23A"></u-icon>
          </view>
          <text>快速入库</text>
        </view>
        <view class="action-item" @tap="quickOutbound">
          <view class="action-icon">
            <u-icon name="arrow-up-circle" size="40" color="#E6A23C"></u-icon>
          </view>
          <text>快速出库</text>
        </view>
        <view class="action-item" @tap="scanCode">
          <view class="action-icon">
            <u-icon name="scan" size="40" color="#409EFF"></u-icon>
          </view>
          <text>扫码出库</text>
        </view>
        <view class="action-item" @tap="navTo('/pages/warehouse/inventory/list')">
          <view class="action-icon">
            <u-icon name="list" size="40" color="#909399"></u-icon>
          </view>
          <text>库存查询</text>
        </view>
      </view>
    </view>

    <!-- 待处理事项 -->
    <view class="pending-tasks">
      <view class="task-title">待处理事项</view>
      <view class="task-list">
        <view
          v-for="task in pendingTasks"
          :key="task.id"
          class="task-item"
          @tap="handleTask(task)"
        >
          <view class="task-content">
            <view class="task-type">{{ task.type }}</view>
            <view class="task-desc">{{ task.description }}</view>
            <view class="task-time">{{ task.time }}</view>
          </view>
          <view class="task-arrow">
            <u-icon name="arrow-right" size="20"></u-icon>
          </view>
        </view>
      </view>
    </view>
  </view>
</template>

<script>
import { statsApi } from '@/api/stats'
import { applyApi } from '@/api/apply'

export default {
  data() {
    return {
      todayStats: {
        pendingApproval: 0,
        pendingPickup: 0,
        inboundCount: 0,
        outboundCount: 0
      },
      pendingTasks: []
    }
  },

  onLoad() {
    this.fetchTodayStats()
    this.fetchPendingTasks()
  },

  // 下拉刷新
  onPullDownRefresh() {
    Promise.all([
      this.fetchTodayStats(),
      this.fetchPendingTasks()
    ]).finally(() => {
      uni.stopPullDownRefresh()
    })
  },

  methods: {
    /**
     * 获取今日统计
     */
    async fetchTodayStats() {
      try {
        const data = await statsApi.getTodayStats()
        this.todayStats = data
      } catch (error) {
        console.error('获取统计失败', error)
      }
    },

    /**
     * 获取待处理任务
     */
    async fetchPendingTasks() {
      try {
        // 查询待审批申请
        const applies = await applyApi.getPendingList({ pageSize: 5 })
        this.pendingTasks = applies.records.map(item => ({
          id: item.id,
          type: '待审批',
          description: `${item.applicantName}的申请`,
          time: this.formatTime(item.applyTime)
        }))
      } catch (error) {
        console.error('获取待处理任务失败', error)
      }
    },

    /**
     * 快速入库
     */
    quickInbound() {
      uni.navigateTo({
        url: '/pages/warehouse/quick-inbound/quick-inbound'
      })
    },

    /**
     * 快速出库
     */
    quickOutbound() {
      uni.navigateTo({
        url: '/pages/warehouse/quick-outbound/quick-outbound'
      })
    },

    /**
     * 扫码出库
     */
    scanCode() {
      uni.scanCode({
        success: (res) => {
          // res.result 是扫码结果
          const outboundNo = res.result
          // 跳转到出库确认页
          uni.navigateTo({
            url: `/pages/warehouse/outbound/confirm?outboundNo=${outboundNo}`
          })
        },
        fail: (error) => {
          uni.showToast({
            title: '扫码失败',
            icon: 'none'
          })
        }
      })
    },

    /**
     * 处理任务
     */
    handleTask(task) {
      if (task.type === '待审批') {
        uni.navigateTo({
          url: `/pages/warehouse/approval/detail?id=${task.id}`
        })
      }
    },

    /**
     * 页面跳转
     */
    navTo(url) {
      uni.navigateTo({ url })
    },

    /**
     * 格式化时间
     */
    formatTime(time) {
      // 简单实现
      return time.substring(0, 16)
    }
  }
}
</script>

<style lang="scss" scoped>
.warehouse-home {
  min-height: 100vh;
  background-color: #f5f5f5;
  padding: 20rpx;
}

.stats-cards {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20rpx;

  .stat-card {
    flex: 1;
    background-color: #fff;
    border-radius: 10rpx;
    padding: 30rpx 20rpx;
    margin: 0 10rpx;
    text-align: center;

    .stat-value {
      font-size: 48rpx;
      font-weight: bold;
      color: #409EFF;
    }

    .stat-label {
      font-size: 24rpx;
      color: #909399;
      margin-top: 10rpx;
    }
  }
}

.quick-actions {
  background-color: #fff;
  border-radius: 10rpx;
  padding: 30rpx;
  margin-bottom: 20rpx;

  .action-title {
    font-size: 32rpx;
    font-weight: bold;
    margin-bottom: 20rpx;
  }

  .action-grid {
    display: flex;
    justify-content: space-between;

    .action-item {
      text-align: center;

      .action-icon {
        width: 100rpx;
        height: 100rpx;
        background-color: #f5f7fa;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 10rpx;
      }

      text {
        font-size: 24rpx;
        color: #606266;
      }
    }
  }
}

.pending-tasks {
  background-color: #fff;
  border-radius: 10rpx;
  padding: 30rpx;

  .task-title {
    font-size: 32rpx;
    font-weight: bold;
    margin-bottom: 20rpx;
  }

  .task-list {
    .task-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20rpx 0;
      border-bottom: 1px solid #ebeef5;

      &:last-child {
        border-bottom: none;
      }

      .task-content {
        flex: 1;

        .task-type {
          font-size: 28rpx;
          color: #E6A23C;
          margin-bottom: 10rpx;
        }

        .task-desc {
          font-size: 28rpx;
          color: #303133;
          margin-bottom: 10rpx;
        }

        .task-time {
          font-size: 24rpx;
          color: #909399;
        }
      }

      .task-arrow {
        color: #C0C4CC;
      }
    }
  }
}
</style>
```

### 5.3 本阶段关键要点

**统计报表要点**:
1. **SQL优化**: 使用UNION ALL合并查询,避免N+1
2. **日期处理**: 前端和后端统一时区和格式
3. **ECharts**: 响应式设计,监听resize事件

**小程序开发要点**:
1. **uni-app**: 一套代码多端运行
2. **rpx单位**: 响应式像素,自动适配屏幕
3. **生命周期**: onLoad/onShow/onPullDownRefresh
4. **扫码**: uni.scanCode API
5. **tabBar**: 配置在pages.json

---

## 阶段六: 测试与上线 (第6周)

### 6.1 单元测试

**MaterialServiceTest.java**:

```java
@SpringBootTest
class MaterialServiceTest {

    @Autowired
    private IMaterialService materialService;

    @Test
    @DisplayName("测试创建物资 - 成功")
    void testCreate_Success() {
        // 准备测试数据
        MaterialCreateDTO dto = new MaterialCreateDTO();
        dto.setMaterialName("测试物资");
        dto.setMaterialCode("TEST001");
        dto.setCategory("测试类");
        dto.setSpec("测试规格");
        dto.setUnit("个");
        dto.setPrice(BigDecimal.valueOf(100));
        dto.setMinStock(BigDecimal.valueOf(10));

        // 执行
        Long id = materialService.create(dto);

        // 断言
        assertNotNull(id);
        assertTrue(id > 0);

        // 验证数据
        Material material = materialService.getById(id);
        assertEquals("测试物资", material.getMaterialName());
        assertEquals("TEST001", material.getMaterialCode());
    }

    @Test
    @DisplayName("测试创建物资 - 编码重复")
    void testCreate_DuplicateCode() {
        // 准备数据
        MaterialCreateDTO dto = new MaterialCreateDTO();
        dto.setMaterialCode("GX001");  // 已存在的编码
        // ... 其他字段

        // 断言抛出异常
        assertThrows(BusinessException.class, () -> {
            materialService.create(dto);
        });
    }

    @Test
    @DisplayName("测试删除物资 - 有库存不能删除")
    void testDelete_HasStock() {
        Long materialId = 1L;  // 有库存的物资

        // 断言抛出异常
        BusinessException exception = assertThrows(BusinessException.class, () -> {
            materialService.delete(materialId);
        });

        assertEquals("该物资有库存,无法删除", exception.getMessage());
    }
}
```

### 6.2 集成测试

**ApplyApprovalIntegrationTest.java**:

```java
@SpringBootTest
@AutoConfigureMockMvc
class ApplyApprovalIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @DisplayName("测试完整的申请审批流程")
    @WithMockUser(username = "test_user", roles = {"USER"})
    void testApplyApprovalFlow() throws Exception {
        // 1. 提交申请
        ApplyCreateDTO applyDTO = new ApplyCreateDTO();
        applyDTO.setPurpose("测试申请");
        applyDTO.setDetails(List.of(
                new ApplyDetailDTO(1L, BigDecimal.valueOf(10))
        ));

        MvcResult createResult = mockMvc.perform(post("/api/applies")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(applyDTO)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200))
                .andReturn();

        Long applyId = JsonPath.read(createResult.getResponse().getContentAsString(), "$.data");

        // 2. 仓管员审批通过
        ApplyApproveDTO approveDTO = new ApplyApproveDTO();
        approveDTO.setResult(1);  // 通过
        approveDTO.setOpinion("同意");

        mockMvc.perform(put("/api/applies/" + applyId + "/approve")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(approveDTO)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200))
                .andExpect(jsonPath("$.data.outboundId").exists());  // 返回出库单ID

        // 3. 验证申请单状态
        mockMvc.perform(get("/api/applies/" + applyId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.data.status").value(1))  // 已通过
                .andExpect(jsonPath("$.data.outboundId").exists());

        // 4. 验证出库单已创建
        MvcResult applyResult = mockMvc.perform(get("/api/applies/" + applyId))
                .andReturn();

        Long outboundId = JsonPath.read(applyResult.getResponse().getContentAsString(),
                "$.data.outboundId");

        mockMvc.perform(get("/api/outbounds/" + outboundId))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.data.status").value(0))  // 待领取
                .andExpect(jsonPath("$.data.source").value(2));  // 申请创建
    }
}
```

### 6.3 性能测试

**JMeter测试计划**:

```xml
<!-- 并发入库测试 -->
<ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="并发入库">
  <stringProp name="ThreadGroup.num_threads">50</stringProp>  <!-- 50并发 -->
  <stringProp name="ThreadGroup.ramp_time">10</stringProp>    <!-- 10秒启动 -->
  <stringProp name="ThreadGroup.duration">60</stringProp>     <!-- 持续60秒 -->
</ThreadGroup>
```

**性能指标**:
- 吞吐量: ≥100 TPS
- 响应时间: P95 < 500ms
- 错误率: < 0.1%
- 并发用户: 50人

### 6.4 部署上线

#### 6.4.1 打包构建

**后端打包**:

```bash
cd backend
mvn clean package -DskipTests

# 生成 target/ct-tibet-wms.jar
```

**前端打包**:

```bash
cd frontend-pc
npm run build

# 生成 dist/ 目录
```

#### 6.4.2 Docker部署

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ct_tibet_wms
    volumes:
      - ./data/mysql:/var/lib/mysql
      - ./sql:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"

  redis:
    image: redis:6.2-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"

  rabbitmq:
    image: rabbitmq:3.12-management
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"
      - "15672:15672"

  backend:
    build: ./backend
    depends_on:
      - mysql
      - redis
      - rabbitmq
    environment:
      SPRING_PROFILES_ACTIVE: prod
    ports:
      - "8080:8080"

  nginx:
    image: nginx:alpine
    depends_on:
      - backend
    volumes:
      - ./frontend-pc/dist:/usr/share/nginx/html
      - ./deploy/nginx/nginx.conf:/etc/nginx/nginx.conf
    ports:
      - "80:80"
      - "443:443"
```

**启动命令**:

```bash
# 创建环境变量文件
cat > .env <<EOF
MYSQL_ROOT_PASSWORD=your_password
REDIS_PASSWORD=your_password
RABBITMQ_USER=admin
RABBITMQ_PASSWORD=your_password
EOF

# 启动所有服务
docker-compose up -d

# 查看日志
docker-compose logs -f backend
```

### 6.5 上线检查清单

**数据库检查**:
- [ ] 执行初始化脚本
- [ ] 导入初始数据(部门、角色、管理员)
- [ ] 创建数据库索引
- [ ] 配置定时备份

**应用检查**:
- [ ] 配置文件环境变量
- [ ] JWT密钥配置
- [ ] 微信小程序AppID配置
- [ ] 文件上传路径配置
- [ ] 日志级别调整为INFO

**安全检查**:
- [ ] HTTPS证书配置
- [ ] 密码加密验证
- [ ] SQL注入测试
- [ ] XSS防护测试
- [ ] 权限控制测试

**性能检查**:
- [ ] 数据库连接池配置
- [ ] Redis缓存测试
- [ ] 慢查询监控
- [ ] 接口响应时间监控

**监控告警**:
- [ ] 应用日志收集(ELK)
- [ ] 服务器监控(CPU/内存/磁盘)
- [ ] 接口异常告警
- [ ] 库存预警通知

### 6.6 运维文档

**日常运维命令**:

```bash
# 查看服务状态
docker-compose ps

# 重启服务
docker-compose restart backend

# 查看日志
docker-compose logs -f --tail=100 backend

# 数据库备份
docker exec wms-mysql mysqldump -uroot -p ct_tibet_wms > backup.sql

# 数据库恢复
docker exec -i wms-mysql mysql -uroot -p ct_tibet_wms < backup.sql

# 清理日志
find /var/log/wms -name "*.log" -mtime +7 -delete
```

**常见问题排查**:

1. **服务无法启动**: 检查端口占用,查看日志
2. **数据库连接失败**: 检查配置,网络连通性
3. **Token验证失败**: 检查密钥配置,时间同步
4. **库存扣减失败**: 检查并发锁,查看库存流水

---

## 总结与进阶

### 核心技术栈掌握

**后端**:
✅ Spring Boot框架搭建
✅ MyBatis-Plus CRUD操作
✅ Spring Security + JWT认证
✅ 事务管理与并发控制
✅ 异步消息与定时任务

**前端**:
✅ Vue 3 组合式API
✅ Pinia状态管理
✅ Element Plus组件库
✅ ECharts数据可视化
✅ uni-app小程序开发

### 核心业务逻辑

✅ 主从表操作(入库单/出库单)
✅ 审批流程(状态机)
✅ 库存管理(乐观锁)
✅ 消息通知(异步)
✅ 定时任务(超时处理)

### 进阶方向

**技术优化**:
1. **缓存优化**: Redis缓存热点数据
2. **消息队列**: RabbitMQ削峰填谷
3. **搜索引擎**: Elasticsearch全文检索
4. **分库分表**: ShardingSphere数据分片

**功能扩展**:
1. **条码管理**: 物资二维码/条形码
2. **盘点功能**: 定期库存盘点
3. **报表导出**: Excel/PDF导出
4. **数据大屏**: 实时数据展示

**架构演进**:
1. **微服务**: Spring Cloud拆分服务
2. **容器化**: Kubernetes编排
3. **DevOps**: CI/CD自动化部署
4. **监控**: Prometheus + Grafana

---

**文档版本**: v1.0
**最后更新**: 2025-11-11
**适用人群**: Java/Vue开发者
**预计学习周期**: 6周
